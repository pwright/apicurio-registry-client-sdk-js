/* tslint:disable */
/* eslint-disable */
/**
 * Apicurio Registry API [v3]
 * Apicurio Registry is a datastore for standard event schemas and API designs. Apicurio Registry enables developers to manage and share the structure of their data using a REST interface. For example, client applications can dynamically push or pull the latest updates to or from the registry without needing to redeploy. Apicurio Registry also enables developers to create rules that govern how registry content can evolve over time. For example, this includes rules for content validation and version compatibility.  The Apicurio Registry REST API enables client applications to manage the artifacts in the registry. This API provides create, read, update, and delete operations for schema and API artifacts, rules, versions, and metadata.   The supported artifact types include: - Apache Avro schema - AsyncAPI specification - Google protocol buffers - GraphQL schema - JSON Schema - Kafka Connect schema - OpenAPI specification - Web Services Description Language - XML Schema Definition   **Important**: The Apicurio Registry REST API is available from `https://MY-REGISTRY-URL/apis/registry/v3` by default. Therefore you must prefix all API operation paths with `/apis/registry/v3` in this case. For example: `/apis/registry/v3/ids/globalIds/{globalId}`. 
 *
 * The version of the OpenAPI document: 3.0.x
 * Contact: apicurio@lists.jboss.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AddVersionToBranch
 */
export interface AddVersionToBranch {
    /**
     * 
     * @type {string}
     * @memberof AddVersionToBranch
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface ArtifactMetaData
 */
export interface ArtifactMetaData {
    /**
     * 
     * @type {string}
     * @memberof ArtifactMetaData
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactMetaData
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactMetaData
     */
    'owner': string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactMetaData
     */
    'createdOn': string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactMetaData
     */
    'modifiedBy': string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactMetaData
     */
    'modifiedOn': string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactMetaData
     */
    'artifactType': string;
    /**
     * User-defined name-value pairs. Name and value must be strings.
     * @type {{ [key: string]: string; }}
     * @memberof ArtifactMetaData
     */
    'labels'?: { [key: string]: string; };
    /**
     * An ID of a single artifact group.
     * @type {string}
     * @memberof ArtifactMetaData
     */
    'groupId': string;
    /**
     * The ID of a single artifact.
     * @type {string}
     * @memberof ArtifactMetaData
     */
    'artifactId': string;
}
/**
 * A reference to a different artifact. Typically used with artifact types that can have dependencies like Protobuf.
 * @export
 * @interface ArtifactReference
 */
export interface ArtifactReference {
    /**
     * 
     * @type {string}
     * @memberof ArtifactReference
     */
    'groupId': string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactReference
     */
    'artifactId': string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactReference
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof ArtifactReference
     */
    'name': string;
}
/**
 * Describes the response received when searching for artifacts.
 * @export
 * @interface ArtifactSearchResults
 */
export interface ArtifactSearchResults {
    /**
     * The artifacts returned in the result set.
     * @type {Array<SearchedArtifact>}
     * @memberof ArtifactSearchResults
     */
    'artifacts': Array<SearchedArtifact>;
    /**
     * The total number of artifacts that matched the query that produced the result set (may be  more than the number of artifacts in the result set).
     * @type {number}
     * @memberof ArtifactSearchResults
     */
    'count': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ArtifactSortBy = {
    ArtifactId: 'artifactId',
    CreatedOn: 'createdOn',
    ModifiedOn: 'modifiedOn',
    ArtifactType: 'artifactType',
    Name: 'name'
} as const;

export type ArtifactSortBy = typeof ArtifactSortBy[keyof typeof ArtifactSortBy];


/**
 * 
 * @export
 * @interface ArtifactTypeInfo
 */
export interface ArtifactTypeInfo {
    /**
     * 
     * @type {string}
     * @memberof ArtifactTypeInfo
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface BranchMetaData
 */
export interface BranchMetaData {
    /**
     * An ID of a single artifact group.
     * @type {string}
     * @memberof BranchMetaData
     */
    'groupId': string;
    /**
     * The ID of a single artifact.
     * @type {string}
     * @memberof BranchMetaData
     */
    'artifactId': string;
    /**
     * The ID of a single artifact branch.
     * @type {string}
     * @memberof BranchMetaData
     */
    'branchId': string;
    /**
     * 
     * @type {string}
     * @memberof BranchMetaData
     */
    'createdOn': string;
    /**
     * 
     * @type {string}
     * @memberof BranchMetaData
     */
    'modifiedBy': string;
    /**
     * 
     * @type {string}
     * @memberof BranchMetaData
     */
    'modifiedOn': string;
    /**
     * 
     * @type {string}
     * @memberof BranchMetaData
     */
    'owner': string;
    /**
     * 
     * @type {string}
     * @memberof BranchMetaData
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BranchMetaData
     */
    'systemDefined': boolean;
}
/**
 * Describes the response received when searching for branches.
 * @export
 * @interface BranchSearchResults
 */
export interface BranchSearchResults {
    /**
     * The branches returned in the result set.
     * @type {Array<SearchedBranch>}
     * @memberof BranchSearchResults
     */
    'branches': Array<SearchedBranch>;
    /**
     * The total number of branches that matched the query that produced the result set (may be  more than the number of branches in the result set).
     * @type {number}
     * @memberof BranchSearchResults
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface Comment
 */
export interface Comment {
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'createdOn': string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'owner': string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'commentId': string;
}
/**
 * 
 * @export
 * @interface ConfigurationProperty
 */
export interface ConfigurationProperty {
    /**
     * 
     * @type {string}
     * @memberof ConfigurationProperty
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ConfigurationProperty
     */
    'value': string;
    /**
     * 
     * @type {string}
     * @memberof ConfigurationProperty
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof ConfigurationProperty
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof ConfigurationProperty
     */
    'description': string;
}
/**
 * Data sent when creating a new artifact.
 * @export
 * @interface CreateArtifact
 */
export interface CreateArtifact {
    /**
     * The ID of a single artifact.
     * @type {string}
     * @memberof CreateArtifact
     */
    'artifactId': string;
    /**
     * 
     * @type {string}
     * @memberof CreateArtifact
     */
    'artifactType'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateArtifact
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateArtifact
     */
    'description'?: string;
    /**
     * User-defined name-value pairs. Name and value must be strings.
     * @type {{ [key: string]: string; }}
     * @memberof CreateArtifact
     */
    'labels'?: { [key: string]: string; };
    /**
     * 
     * @type {CreateVersion}
     * @memberof CreateArtifact
     */
    'firstVersion'?: CreateVersion;
}
/**
 * 
 * @export
 * @interface CreateArtifactResponse
 */
export interface CreateArtifactResponse {
    /**
     * 
     * @type {ArtifactMetaData}
     * @memberof CreateArtifactResponse
     */
    'artifact': ArtifactMetaData;
    /**
     * 
     * @type {VersionMetaData}
     * @memberof CreateArtifactResponse
     */
    'version'?: VersionMetaData;
}
/**
 * 
 * @export
 * @interface CreateBranch
 */
export interface CreateBranch {
    /**
     * 
     * @type {string}
     * @memberof CreateBranch
     */
    'description'?: string;
    /**
     * The ID of a single artifact branch.
     * @type {string}
     * @memberof CreateBranch
     */
    'branchId': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateBranch
     */
    'versions'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CreateGroup
 */
export interface CreateGroup {
    /**
     * 
     * @type {string}
     * @memberof CreateGroup
     */
    'description'?: string;
    /**
     * User-defined name-value pairs. Name and value must be strings.
     * @type {{ [key: string]: string; }}
     * @memberof CreateGroup
     */
    'labels'?: { [key: string]: string; };
    /**
     * An ID of a single artifact group.
     * @type {string}
     * @memberof CreateGroup
     */
    'groupId': string;
}
/**
 * 
 * @export
 * @interface CreateRule
 */
export interface CreateRule {
    /**
     * 
     * @type {string}
     * @memberof CreateRule
     */
    'config': string;
    /**
     * 
     * @type {RuleType}
     * @memberof CreateRule
     */
    'ruleType'?: RuleType;
}


/**
 * 
 * @export
 * @interface CreateVersion
 */
export interface CreateVersion {
    /**
     * A single version of an artifact.  Can be provided by the client when creating a new version, or it can be server-generated.  The value can be any string unique to the artifact, but it is recommended to use a simple integer or a semver value.
     * @type {string}
     * @memberof CreateVersion
     */
    'version'?: string;
    /**
     * 
     * @type {VersionContent}
     * @memberof CreateVersion
     */
    'content': VersionContent;
    /**
     * 
     * @type {string}
     * @memberof CreateVersion
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateVersion
     */
    'description'?: string;
    /**
     * User-defined name-value pairs. Name and value must be strings.
     * @type {{ [key: string]: string; }}
     * @memberof CreateVersion
     */
    'labels'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateVersion
     */
    'branches'?: Array<string>;
}
/**
 * Models a download \"link\".  Useful for browser use-cases.
 * @export
 * @interface DownloadRef
 */
export interface DownloadRef {
    /**
     * 
     * @type {string}
     * @memberof DownloadRef
     */
    'downloadId': string;
    /**
     * 
     * @type {string}
     * @memberof DownloadRef
     */
    'href'?: string;
}
/**
 * 
 * @export
 * @interface EditableArtifactMetaData
 */
export interface EditableArtifactMetaData {
    /**
     * 
     * @type {string}
     * @memberof EditableArtifactMetaData
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditableArtifactMetaData
     */
    'description'?: string;
    /**
     * User-defined name-value pairs. Name and value must be strings.
     * @type {{ [key: string]: string; }}
     * @memberof EditableArtifactMetaData
     */
    'labels'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof EditableArtifactMetaData
     */
    'owner'?: string;
}
/**
 * 
 * @export
 * @interface EditableBranchMetaData
 */
export interface EditableBranchMetaData {
    /**
     * 
     * @type {string}
     * @memberof EditableBranchMetaData
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface EditableGroupMetaData
 */
export interface EditableGroupMetaData {
    /**
     * 
     * @type {string}
     * @memberof EditableGroupMetaData
     */
    'description'?: string;
    /**
     * User-defined name-value pairs. Name and value must be strings.
     * @type {{ [key: string]: string; }}
     * @memberof EditableGroupMetaData
     */
    'labels'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface EditableVersionMetaData
 */
export interface EditableVersionMetaData {
    /**
     * 
     * @type {string}
     * @memberof EditableVersionMetaData
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof EditableVersionMetaData
     */
    'description'?: string;
    /**
     * User-defined name-value pairs. Name and value must be strings.
     * @type {{ [key: string]: string; }}
     * @memberof EditableVersionMetaData
     */
    'labels'?: { [key: string]: string; };
    /**
     * 
     * @type {VersionState}
     * @memberof EditableVersionMetaData
     */
    'state'?: VersionState;
}


/**
 * 
 * @export
 * @interface GroupMetaData
 */
export interface GroupMetaData {
    /**
     * 
     * @type {string}
     * @memberof GroupMetaData
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof GroupMetaData
     */
    'owner': string;
    /**
     * 
     * @type {string}
     * @memberof GroupMetaData
     */
    'createdOn': string;
    /**
     * 
     * @type {string}
     * @memberof GroupMetaData
     */
    'modifiedBy': string;
    /**
     * 
     * @type {string}
     * @memberof GroupMetaData
     */
    'modifiedOn': string;
    /**
     * User-defined name-value pairs. Name and value must be strings.
     * @type {{ [key: string]: string; }}
     * @memberof GroupMetaData
     */
    'labels': { [key: string]: string; };
    /**
     * An ID of a single artifact group.
     * @type {string}
     * @memberof GroupMetaData
     */
    'groupId': string;
}
/**
 * Describes the response received when searching for groups.
 * @export
 * @interface GroupSearchResults
 */
export interface GroupSearchResults {
    /**
     * The groups returned in the result set.
     * @type {Array<SearchedGroup>}
     * @memberof GroupSearchResults
     */
    'groups': Array<SearchedGroup>;
    /**
     * The total number of groups that matched the query that produced the result set (may be  more than the number of groups in the result set).
     * @type {number}
     * @memberof GroupSearchResults
     */
    'count': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const GroupSortBy = {
    GroupId: 'groupId',
    CreatedOn: 'createdOn'
} as const;

export type GroupSortBy = typeof GroupSortBy[keyof typeof GroupSortBy];


/**
 * How to handle references when retrieving content.  References can either be left unchanged (`PRESERVE`), re-written so they are valid in the context of the registry (`REWRITE`), or fully dereferenced such that all externally referenced content is internalized (`DEREFERENCE`).
 * @export
 * @enum {string}
 */

export const HandleReferencesType = {
    Preserve: 'PRESERVE',
    Dereference: 'DEREFERENCE',
    Rewrite: 'REWRITE'
} as const;

export type HandleReferencesType = typeof HandleReferencesType[keyof typeof HandleReferencesType];


/**
 * 
 * @export
 * @enum {string}
 */

export const IfArtifactExists = {
    Fail: 'FAIL',
    CreateVersion: 'CREATE_VERSION',
    FindOrCreateVersion: 'FIND_OR_CREATE_VERSION'
} as const;

export type IfArtifactExists = typeof IfArtifactExists[keyof typeof IfArtifactExists];


/**
 * List of limitations on used resources, that are applied on the current instance of Registry. Keys represent the resource type and are suffixed by the corresponding unit. Values are integers. Only non-negative values are allowed, with the exception of -1, which means that the limit is not applied.
 * @export
 * @interface Limits
 */
export interface Limits {
    /**
     * 
     * @type {number}
     * @memberof Limits
     */
    'maxTotalSchemasCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Limits
     */
    'maxSchemaSizeBytes'?: number;
    /**
     * 
     * @type {number}
     * @memberof Limits
     */
    'maxArtifactsCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Limits
     */
    'maxVersionsPerArtifactCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Limits
     */
    'maxArtifactPropertiesCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Limits
     */
    'maxPropertyKeySizeBytes'?: number;
    /**
     * 
     * @type {number}
     * @memberof Limits
     */
    'maxPropertyValueSizeBytes'?: number;
    /**
     * 
     * @type {number}
     * @memberof Limits
     */
    'maxArtifactLabelsCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof Limits
     */
    'maxLabelSizeBytes'?: number;
    /**
     * 
     * @type {number}
     * @memberof Limits
     */
    'maxArtifactNameLengthChars'?: number;
    /**
     * 
     * @type {number}
     * @memberof Limits
     */
    'maxArtifactDescriptionLengthChars'?: number;
    /**
     * 
     * @type {number}
     * @memberof Limits
     */
    'maxRequestsPerSecondCount'?: number;
}
/**
 * All error responses, whether `4xx` or `5xx` will include one of these as the response body.
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * The short error message.
     * @type {string}
     * @memberof ModelError
     */
    'message'?: string;
    /**
     * The server-side error code.
     * @type {number}
     * @memberof ModelError
     */
    'error_code'?: number;
    /**
     * Full details about the error.  This might contain a server stack trace, for example.
     * @type {string}
     * @memberof ModelError
     */
    'detail'?: string;
    /**
     * The error name - typically the classname of the exception thrown by the server.
     * @type {string}
     * @memberof ModelError
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface NewComment
 */
export interface NewComment {
    /**
     * 
     * @type {string}
     * @memberof NewComment
     */
    'value': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ReferenceType = {
    Outbound: 'OUTBOUND',
    Inbound: 'INBOUND'
} as const;

export type ReferenceType = typeof ReferenceType[keyof typeof ReferenceType];


/**
 * 
 * @export
 * @interface ReplaceBranchVersions
 */
export interface ReplaceBranchVersions {
    /**
     * 
     * @type {Array<string>}
     * @memberof ReplaceBranchVersions
     */
    'versions': Array<string>;
}
/**
 * The mapping between a user/principal and their role.
 * @export
 * @interface RoleMapping
 */
export interface RoleMapping {
    /**
     * 
     * @type {string}
     * @memberof RoleMapping
     */
    'principalId': string;
    /**
     * 
     * @type {RoleType}
     * @memberof RoleMapping
     */
    'role': RoleType;
    /**
     * A friendly name for the principal.
     * @type {string}
     * @memberof RoleMapping
     */
    'principalName'?: string;
}


/**
 * Describes the response received when searching for artifacts.
 * @export
 * @interface RoleMappingSearchResults
 */
export interface RoleMappingSearchResults {
    /**
     * The role mappings returned in the result set.
     * @type {Array<RoleMapping>}
     * @memberof RoleMappingSearchResults
     */
    'roleMappings': Array<RoleMapping>;
    /**
     * The total number of role mappings that matched the query that produced the result set (may be  more than the number of role mappings in the result set).
     * @type {number}
     * @memberof RoleMappingSearchResults
     */
    'count': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const RoleType = {
    ReadOnly: 'READ_ONLY',
    Developer: 'DEVELOPER',
    Admin: 'ADMIN'
} as const;

export type RoleType = typeof RoleType[keyof typeof RoleType];


/**
 * 
 * @export
 * @interface Rule
 */
export interface Rule {
    /**
     * 
     * @type {string}
     * @memberof Rule
     */
    'config': string;
    /**
     * 
     * @type {RuleType}
     * @memberof Rule
     */
    'ruleType'?: RuleType;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const RuleType = {
    Validity: 'VALIDITY',
    Compatibility: 'COMPATIBILITY',
    Integrity: 'INTEGRITY'
} as const;

export type RuleType = typeof RuleType[keyof typeof RuleType];


/**
 * 
 * @export
 * @interface RuleViolationCause
 */
export interface RuleViolationCause {
    /**
     * 
     * @type {string}
     * @memberof RuleViolationCause
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof RuleViolationCause
     */
    'context'?: string;
}
/**
 * All error responses, whether `4xx` or `5xx` will include one of these as the response body.
 * @export
 * @interface RuleViolationError
 */
export interface RuleViolationError {
    /**
     * The short error message.
     * @type {string}
     * @memberof RuleViolationError
     */
    'message'?: string;
    /**
     * The server-side error code.
     * @type {number}
     * @memberof RuleViolationError
     */
    'error_code'?: number;
    /**
     * Full details about the error.  This might contain a server stack trace, for example.
     * @type {string}
     * @memberof RuleViolationError
     */
    'detail'?: string;
    /**
     * The error name - typically the classname of the exception thrown by the server.
     * @type {string}
     * @memberof RuleViolationError
     */
    'name'?: string;
    /**
     * List of rule violation causes.
     * @type {Array<RuleViolationCause>}
     * @memberof RuleViolationError
     */
    'causes': Array<RuleViolationCause>;
}
/**
 * Models a single artifact from the result set returned when searching for artifacts.
 * @export
 * @interface SearchedArtifact
 */
export interface SearchedArtifact {
    /**
     * 
     * @type {string}
     * @memberof SearchedArtifact
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchedArtifact
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchedArtifact
     */
    'createdOn': string;
    /**
     * 
     * @type {string}
     * @memberof SearchedArtifact
     */
    'owner': string;
    /**
     * 
     * @type {string}
     * @memberof SearchedArtifact
     */
    'artifactType': string;
    /**
     * 
     * @type {string}
     * @memberof SearchedArtifact
     */
    'modifiedOn': string;
    /**
     * 
     * @type {string}
     * @memberof SearchedArtifact
     */
    'modifiedBy': string;
    /**
     * An ID of a single artifact group.
     * @type {string}
     * @memberof SearchedArtifact
     */
    'groupId': string;
    /**
     * The ID of a single artifact.
     * @type {string}
     * @memberof SearchedArtifact
     */
    'artifactId': string;
}
/**
 * 
 * @export
 * @interface SearchedBranch
 */
export interface SearchedBranch {
    /**
     * An ID of a single artifact group.
     * @type {string}
     * @memberof SearchedBranch
     */
    'groupId': string;
    /**
     * The ID of a single artifact.
     * @type {string}
     * @memberof SearchedBranch
     */
    'artifactId': string;
    /**
     * The ID of a single artifact branch.
     * @type {string}
     * @memberof SearchedBranch
     */
    'branchId': string;
    /**
     * 
     * @type {string}
     * @memberof SearchedBranch
     */
    'createdOn': string;
    /**
     * 
     * @type {string}
     * @memberof SearchedBranch
     */
    'owner': string;
    /**
     * 
     * @type {string}
     * @memberof SearchedBranch
     */
    'modifiedOn': string;
    /**
     * 
     * @type {string}
     * @memberof SearchedBranch
     */
    'modifiedBy': string;
    /**
     * 
     * @type {string}
     * @memberof SearchedBranch
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SearchedBranch
     */
    'systemDefined': boolean;
}
/**
 * Models a single group from the result set returned when searching for groups.
 * @export
 * @interface SearchedGroup
 */
export interface SearchedGroup {
    /**
     * 
     * @type {string}
     * @memberof SearchedGroup
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof SearchedGroup
     */
    'createdOn': string;
    /**
     * 
     * @type {string}
     * @memberof SearchedGroup
     */
    'owner': string;
    /**
     * 
     * @type {string}
     * @memberof SearchedGroup
     */
    'modifiedOn': string;
    /**
     * 
     * @type {string}
     * @memberof SearchedGroup
     */
    'modifiedBy': string;
    /**
     * An ID of a single artifact group.
     * @type {string}
     * @memberof SearchedGroup
     */
    'groupId': string;
}
/**
 * Models a single artifact from the result set returned when searching for artifacts.
 * @export
 * @interface SearchedVersion
 */
export interface SearchedVersion {
    /**
     * 
     * @type {string}
     * @memberof SearchedVersion
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchedVersion
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchedVersion
     */
    'createdOn': string;
    /**
     * 
     * @type {string}
     * @memberof SearchedVersion
     */
    'owner': string;
    /**
     * 
     * @type {string}
     * @memberof SearchedVersion
     */
    'artifactType': string;
    /**
     * 
     * @type {VersionState}
     * @memberof SearchedVersion
     */
    'state': VersionState;
    /**
     * 
     * @type {number}
     * @memberof SearchedVersion
     */
    'globalId': number;
    /**
     * A single version of an artifact.  Can be provided by the client when creating a new version, or it can be server-generated.  The value can be any string unique to the artifact, but it is recommended to use a simple integer or a semver value.
     * @type {string}
     * @memberof SearchedVersion
     */
    'version': string;
    /**
     * 
     * @type {number}
     * @memberof SearchedVersion
     */
    'contentId': number;
    /**
     * The ID of a single artifact.
     * @type {string}
     * @memberof SearchedVersion
     */
    'artifactId': string;
    /**
     * An ID of a single artifact group.
     * @type {string}
     * @memberof SearchedVersion
     */
    'groupId'?: string;
}


/**
 * 
 * @export
 * @interface SnapshotMetaData
 */
export interface SnapshotMetaData {
    /**
     * 
     * @type {string}
     * @memberof SnapshotMetaData
     */
    'snapshotId': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SortOrder = {
    Asc: 'asc',
    Desc: 'desc'
} as const;

export type SortOrder = typeof SortOrder[keyof typeof SortOrder];


/**
 * 
 * @export
 * @interface SystemInfo
 */
export interface SystemInfo {
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof SystemInfo
     */
    'builtOn'?: string;
}
/**
 * 
 * @export
 * @interface UpdateConfigurationProperty
 */
export interface UpdateConfigurationProperty {
    /**
     * 
     * @type {string}
     * @memberof UpdateConfigurationProperty
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface UpdateRole
 */
export interface UpdateRole {
    /**
     * 
     * @type {RoleType}
     * @memberof UpdateRole
     */
    'role': RoleType;
}


/**
 * Information about a single user.
 * @export
 * @interface UserInfo
 */
export interface UserInfo {
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    'displayName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserInfo
     */
    'admin'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserInfo
     */
    'developer'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserInfo
     */
    'viewer'?: boolean;
}
/**
 * Defines the user interface configuration data type.
 * @export
 * @interface UserInterfaceConfig
 */
export interface UserInterfaceConfig {
    /**
     * 
     * @type {UserInterfaceConfigUi}
     * @memberof UserInterfaceConfig
     */
    'ui'?: UserInterfaceConfigUi;
    /**
     * 
     * @type {UserInterfaceConfigAuth}
     * @memberof UserInterfaceConfig
     */
    'auth': UserInterfaceConfigAuth;
    /**
     * 
     * @type {UserInterfaceConfigFeatures}
     * @memberof UserInterfaceConfig
     */
    'features'?: UserInterfaceConfigFeatures;
}
/**
 * 
 * @export
 * @interface UserInterfaceConfigAuth
 */
export interface UserInterfaceConfigAuth {
    /**
     * 
     * @type {string}
     * @memberof UserInterfaceConfigAuth
     */
    'type'?: UserInterfaceConfigAuthTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof UserInterfaceConfigAuth
     */
    'rbacEnabled': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserInterfaceConfigAuth
     */
    'obacEnabled': boolean;
    /**
     * User-defined name-value pairs. Name and value must be strings.
     * @type {{ [key: string]: string; }}
     * @memberof UserInterfaceConfigAuth
     */
    'options'?: { [key: string]: string; };
}

export const UserInterfaceConfigAuthTypeEnum = {
    None: 'none',
    Basic: 'basic',
    Oidc: 'oidc'
} as const;

export type UserInterfaceConfigAuthTypeEnum = typeof UserInterfaceConfigAuthTypeEnum[keyof typeof UserInterfaceConfigAuthTypeEnum];

/**
 * 
 * @export
 * @interface UserInterfaceConfigFeatures
 */
export interface UserInterfaceConfigFeatures {
    /**
     * 
     * @type {boolean}
     * @memberof UserInterfaceConfigFeatures
     */
    'readOnly'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserInterfaceConfigFeatures
     */
    'breadcrumbs'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserInterfaceConfigFeatures
     */
    'roleManagement'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserInterfaceConfigFeatures
     */
    'settings'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserInterfaceConfigFeatures
     */
    'deleteGroup'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserInterfaceConfigFeatures
     */
    'deleteArtifact'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserInterfaceConfigFeatures
     */
    'deleteVersion'?: boolean;
}
/**
 * 
 * @export
 * @interface UserInterfaceConfigUi
 */
export interface UserInterfaceConfigUi {
    /**
     * 
     * @type {string}
     * @memberof UserInterfaceConfigUi
     */
    'contextPath'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInterfaceConfigUi
     */
    'navPrefixPath'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserInterfaceConfigUi
     */
    'oaiDocsUrl'?: string;
}
/**
 * 
 * @export
 * @interface VersionContent
 */
export interface VersionContent {
    /**
     * Raw content of the artifact version or a valid (and accessible) URL where the content can be found.
     * @type {string}
     * @memberof VersionContent
     */
    'content': string;
    /**
     * Collection of references to other artifacts.
     * @type {Array<ArtifactReference>}
     * @memberof VersionContent
     */
    'references'?: Array<ArtifactReference>;
    /**
     * The content-type, such as `application/json` or `text/xml`.
     * @type {string}
     * @memberof VersionContent
     */
    'contentType': string;
}
/**
 * 
 * @export
 * @interface VersionMetaData
 */
export interface VersionMetaData {
    /**
     * A single version of an artifact.  Can be provided by the client when creating a new version, or it can be server-generated.  The value can be any string unique to the artifact, but it is recommended to use a simple integer or a semver value.
     * @type {string}
     * @memberof VersionMetaData
     */
    'version': string;
    /**
     * 
     * @type {string}
     * @memberof VersionMetaData
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof VersionMetaData
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof VersionMetaData
     */
    'owner': string;
    /**
     * 
     * @type {string}
     * @memberof VersionMetaData
     */
    'createdOn': string;
    /**
     * 
     * @type {string}
     * @memberof VersionMetaData
     */
    'artifactType': string;
    /**
     * 
     * @type {number}
     * @memberof VersionMetaData
     */
    'globalId': number;
    /**
     * 
     * @type {VersionState}
     * @memberof VersionMetaData
     */
    'state'?: VersionState;
    /**
     * User-defined name-value pairs. Name and value must be strings.
     * @type {{ [key: string]: string; }}
     * @memberof VersionMetaData
     */
    'labels'?: { [key: string]: string; };
    /**
     * An ID of a single artifact group.
     * @type {string}
     * @memberof VersionMetaData
     */
    'groupId'?: string;
    /**
     * 
     * @type {number}
     * @memberof VersionMetaData
     */
    'contentId': number;
    /**
     * The ID of a single artifact.
     * @type {string}
     * @memberof VersionMetaData
     */
    'artifactId': string;
}


/**
 * Describes the response received when searching for artifacts.
 * @export
 * @interface VersionSearchResults
 */
export interface VersionSearchResults {
    /**
     * The total number of versions that matched the query (may be more than the number of versions returned in the result set).
     * @type {number}
     * @memberof VersionSearchResults
     */
    'count': number;
    /**
     * The collection of artifact versions returned in the result set.
     * @type {Array<SearchedVersion>}
     * @memberof VersionSearchResults
     */
    'versions': Array<SearchedVersion>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const VersionSortBy = {
    Version: 'version',
    Name: 'name',
    CreatedOn: 'createdOn',
    ModifiedOn: 'modifiedOn',
    GlobalId: 'globalId'
} as const;

export type VersionSortBy = typeof VersionSortBy[keyof typeof VersionSortBy];


/**
 * Describes the state of an artifact or artifact version.  The following states are possible:  * ENABLED * DISABLED * DEPRECATED 
 * @export
 * @enum {string}
 */

export const VersionState = {
    Enabled: 'ENABLED',
    Disabled: 'DISABLED',
    Deprecated: 'DEPRECATED'
} as const;

export type VersionState = typeof VersionState[keyof typeof VersionState];



/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a rule to the list of globally configured rules.  This operation can fail for the following reasons:  * The rule type is unknown (HTTP error `400`) * The rule already exists (HTTP error `409`) * A server error occurred (HTTP error `500`) 
         * @summary Create global rule
         * @param {CreateRule} createRule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGlobalRule: async (createRule: CreateRule, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createRule' is not null or undefined
            assertParamExists('createGlobalRule', 'createRule', createRule)
            const localVarPath = `/admin/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new mapping between a user/principal and a role.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`)  
         * @summary Create a new role mapping
         * @param {RoleMapping} roleMapping 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoleMapping: async (roleMapping: RoleMapping, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleMapping' is not null or undefined
            assertParamExists('createRoleMapping', 'roleMapping', roleMapping)
            const localVarPath = `/admin/roleMappings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(roleMapping, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes all globally configured rules.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary Delete all global rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllGlobalRules: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a single global rule.  If this is the only rule configured, this is the same as deleting **all** rules.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * Rule cannot be deleted (HTTP error `409`) * A server error occurred (HTTP error `500`) 
         * @summary Delete global rule
         * @param {RuleType} ruleType The unique name/type of a rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGlobalRule: async (ruleType: RuleType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ruleType' is not null or undefined
            assertParamExists('deleteGlobalRule', 'ruleType', ruleType)
            const localVarPath = `/admin/rules/{ruleType}`
                .replace(`{${"ruleType"}}`, encodeURIComponent(String(ruleType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a single role mapping, effectively denying access to a user/principal.  This operation can fail for the following reasons:  * No role mapping for the principalId exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Delete a role mapping
         * @param {string} principalId Unique id of a principal (typically either a user or service account).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoleMapping: async (principalId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'principalId' is not null or undefined
            assertParamExists('deleteRoleMapping', 'principalId', principalId)
            const localVarPath = `/admin/roleMappings/{principalId}`
                .replace(`{${"principalId"}}`, encodeURIComponent(String(principalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Exports registry data as a ZIP archive.
         * @summary Export registry data
         * @param {boolean} [forBrowser] Indicates if the operation is done for a browser.  If true, the response will be a JSON payload with a property called &#x60;href&#x60;.  This &#x60;href&#x60; will be a single-use, naked download link suitable for use by a web browser to download the content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportData: async (forBrowser?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (forBrowser !== undefined) {
                localVarQueryParameter['forBrowser'] = forBrowser;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the value of a single configuration property.  This operation may fail for one of the following reasons:  * Property not found or not configured (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get configuration property value
         * @param {string} propertyName The name of a configuration property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigProperty: async (propertyName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'propertyName' is not null or undefined
            assertParamExists('getConfigProperty', 'propertyName', propertyName)
            const localVarPath = `/admin/config/properties/{propertyName}`
                .replace(`{${"propertyName"}}`, encodeURIComponent(String(propertyName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about the named globally configured rule.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get global rule configuration
         * @param {RuleType} ruleType The unique name/type of a rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGlobalRuleConfig: async (ruleType: RuleType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ruleType' is not null or undefined
            assertParamExists('getGlobalRuleConfig', 'ruleType', ruleType)
            const localVarPath = `/admin/rules/{ruleType}`
                .replace(`{${"ruleType"}}`, encodeURIComponent(String(ruleType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the details of a single role mapping (by `principalId`).  This operation can fail for the following reasons:  * No role mapping for the `principalId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Return a single role mapping
         * @param {string} principalId Unique id of a principal (typically either a user or service account).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleMapping: async (principalId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'principalId' is not null or undefined
            assertParamExists('getRoleMapping', 'principalId', principalId)
            const localVarPath = `/admin/roleMappings/{principalId}`
                .replace(`{${"principalId"}}`, encodeURIComponent(String(principalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Imports registry data that was previously exported using the `/admin/export` operation.
         * @summary Import registry data
         * @param {File} body The ZIP file representing the previously exported registry data.
         * @param {boolean} [xRegistryPreserveGlobalId] If this header is set to false, global ids of imported data will be ignored and replaced by next id in global id sequence. This allows to import any data even thought the global ids would cause a conflict.
         * @param {boolean} [xRegistryPreserveContentId] If this header is set to false, content ids of imported data will be ignored and replaced by next id in content id sequence. The mapping between content and artifacts will be preserved. This allows to import any data even thought the content ids would cause a conflict.
         * @param {boolean} [requireEmptyRegistry] Query parameter indicating whether the registry must be empty before allowing data to be imported.  Defaults to &#x60;true&#x60; if omitted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importData: async (body: File, xRegistryPreserveGlobalId?: boolean, xRegistryPreserveContentId?: boolean, requireEmptyRegistry?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('importData', 'body', body)
            const localVarPath = `/admin/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (requireEmptyRegistry !== undefined) {
                localVarQueryParameter['requireEmptyRegistry'] = requireEmptyRegistry;
            }

            if (xRegistryPreserveGlobalId != null) {
                localVarHeaderParameter['X-Registry-Preserve-GlobalId'] = typeof xRegistryPreserveGlobalId === 'string'
                    ? xRegistryPreserveGlobalId
                    : JSON.stringify(xRegistryPreserveGlobalId);
            }

            if (xRegistryPreserveContentId != null) {
                localVarHeaderParameter['X-Registry-Preserve-ContentId'] = typeof xRegistryPreserveContentId === 'string'
                    ? xRegistryPreserveContentId
                    : JSON.stringify(xRegistryPreserveContentId);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/zip';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of all the configured artifact types.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary List artifact types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifactTypes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/config/artifactTypes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all configuration properties that have been set.  The list is not paged.  This operation may fail for one of the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary List all configuration properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConfigProperties: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/config/properties`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of all the currently configured global rules (if any).  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary List global rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGlobalRules: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of all role mappings configured in the registry (if any).  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary List all role mappings
         * @param {number} [limit] The number of role mappings to return.  Defaults to 20.
         * @param {number} [offset] The number of role mappings to skip before starting the result set.  Defaults to 0.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoleMappings: async (limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/roleMappings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resets the value of a single configuration property.  This will return the property to its default value (see external documentation for supported properties and their default values).  This operation may fail for one of the following reasons:  * Property not found or not configured (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Reset a configuration property
         * @param {string} propertyName The name of a configuration property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetConfigProperty: async (propertyName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'propertyName' is not null or undefined
            assertParamExists('resetConfigProperty', 'propertyName', propertyName)
            const localVarPath = `/admin/config/properties/{propertyName}`
                .replace(`{${"propertyName"}}`, encodeURIComponent(String(propertyName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Triggers the creation of a snapshot of the internal database for compatible storages.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary Trigger storage snapshot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerSnapshot: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/snapshots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the value of a single configuration property.  This operation may fail for one of the following reasons:  * Property not found or not configured (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Update a configuration property
         * @param {string} propertyName The name of a configuration property.
         * @param {UpdateConfigurationProperty} updateConfigurationProperty 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfigProperty: async (propertyName: string, updateConfigurationProperty: UpdateConfigurationProperty, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'propertyName' is not null or undefined
            assertParamExists('updateConfigProperty', 'propertyName', propertyName)
            // verify required parameter 'updateConfigurationProperty' is not null or undefined
            assertParamExists('updateConfigProperty', 'updateConfigurationProperty', updateConfigurationProperty)
            const localVarPath = `/admin/config/properties/{propertyName}`
                .replace(`{${"propertyName"}}`, encodeURIComponent(String(propertyName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateConfigurationProperty, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the configuration for a globally configured rule.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Update global rule configuration
         * @param {RuleType} ruleType The unique name/type of a rule.
         * @param {Rule} rule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGlobalRuleConfig: async (ruleType: RuleType, rule: Rule, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ruleType' is not null or undefined
            assertParamExists('updateGlobalRuleConfig', 'ruleType', ruleType)
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('updateGlobalRuleConfig', 'rule', rule)
            const localVarPath = `/admin/rules/{ruleType}`
                .replace(`{${"ruleType"}}`, encodeURIComponent(String(ruleType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a single role mapping for one user/principal.  This operation can fail for the following reasons:  * No role mapping for the principalId exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Update a role mapping
         * @param {string} principalId Unique id of a principal (typically either a user or service account).
         * @param {UpdateRole} updateRole 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoleMapping: async (principalId: string, updateRole: UpdateRole, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'principalId' is not null or undefined
            assertParamExists('updateRoleMapping', 'principalId', principalId)
            // verify required parameter 'updateRole' is not null or undefined
            assertParamExists('updateRoleMapping', 'updateRole', updateRole)
            const localVarPath = `/admin/roleMappings/{principalId}`
                .replace(`{${"principalId"}}`, encodeURIComponent(String(principalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateRole, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a rule to the list of globally configured rules.  This operation can fail for the following reasons:  * The rule type is unknown (HTTP error `400`) * The rule already exists (HTTP error `409`) * A server error occurred (HTTP error `500`) 
         * @summary Create global rule
         * @param {CreateRule} createRule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGlobalRule(createRule: CreateRule, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGlobalRule(createRule, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.createGlobalRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new mapping between a user/principal and a role.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`)  
         * @summary Create a new role mapping
         * @param {RoleMapping} roleMapping 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRoleMapping(roleMapping: RoleMapping, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRoleMapping(roleMapping, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.createRoleMapping']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes all globally configured rules.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary Delete all global rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllGlobalRules(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllGlobalRules(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.deleteAllGlobalRules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a single global rule.  If this is the only rule configured, this is the same as deleting **all** rules.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * Rule cannot be deleted (HTTP error `409`) * A server error occurred (HTTP error `500`) 
         * @summary Delete global rule
         * @param {RuleType} ruleType The unique name/type of a rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGlobalRule(ruleType: RuleType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGlobalRule(ruleType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.deleteGlobalRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a single role mapping, effectively denying access to a user/principal.  This operation can fail for the following reasons:  * No role mapping for the principalId exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Delete a role mapping
         * @param {string} principalId Unique id of a principal (typically either a user or service account).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRoleMapping(principalId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRoleMapping(principalId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.deleteRoleMapping']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Exports registry data as a ZIP archive.
         * @summary Export registry data
         * @param {boolean} [forBrowser] Indicates if the operation is done for a browser.  If true, the response will be a JSON payload with a property called &#x60;href&#x60;.  This &#x60;href&#x60; will be a single-use, naked download link suitable for use by a web browser to download the content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportData(forBrowser?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportData(forBrowser, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.exportData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the value of a single configuration property.  This operation may fail for one of the following reasons:  * Property not found or not configured (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get configuration property value
         * @param {string} propertyName The name of a configuration property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfigProperty(propertyName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigurationProperty>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfigProperty(propertyName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getConfigProperty']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns information about the named globally configured rule.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get global rule configuration
         * @param {RuleType} ruleType The unique name/type of a rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGlobalRuleConfig(ruleType: RuleType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGlobalRuleConfig(ruleType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getGlobalRuleConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets the details of a single role mapping (by `principalId`).  This operation can fail for the following reasons:  * No role mapping for the `principalId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Return a single role mapping
         * @param {string} principalId Unique id of a principal (typically either a user or service account).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoleMapping(principalId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleMapping>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoleMapping(principalId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.getRoleMapping']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Imports registry data that was previously exported using the `/admin/export` operation.
         * @summary Import registry data
         * @param {File} body The ZIP file representing the previously exported registry data.
         * @param {boolean} [xRegistryPreserveGlobalId] If this header is set to false, global ids of imported data will be ignored and replaced by next id in global id sequence. This allows to import any data even thought the global ids would cause a conflict.
         * @param {boolean} [xRegistryPreserveContentId] If this header is set to false, content ids of imported data will be ignored and replaced by next id in content id sequence. The mapping between content and artifacts will be preserved. This allows to import any data even thought the content ids would cause a conflict.
         * @param {boolean} [requireEmptyRegistry] Query parameter indicating whether the registry must be empty before allowing data to be imported.  Defaults to &#x60;true&#x60; if omitted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importData(body: File, xRegistryPreserveGlobalId?: boolean, xRegistryPreserveContentId?: boolean, requireEmptyRegistry?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importData(body, xRegistryPreserveGlobalId, xRegistryPreserveContentId, requireEmptyRegistry, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.importData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets a list of all the configured artifact types.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary List artifact types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listArtifactTypes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTypeInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listArtifactTypes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.listArtifactTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all configuration properties that have been set.  The list is not paged.  This operation may fail for one of the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary List all configuration properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConfigProperties(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConfigurationProperty>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConfigProperties(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.listConfigProperties']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets a list of all the currently configured global rules (if any).  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary List global rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGlobalRules(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RuleType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGlobalRules(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.listGlobalRules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets a list of all role mappings configured in the registry (if any).  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary List all role mappings
         * @param {number} [limit] The number of role mappings to return.  Defaults to 20.
         * @param {number} [offset] The number of role mappings to skip before starting the result set.  Defaults to 0.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRoleMappings(limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleMappingSearchResults>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRoleMappings(limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.listRoleMappings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Resets the value of a single configuration property.  This will return the property to its default value (see external documentation for supported properties and their default values).  This operation may fail for one of the following reasons:  * Property not found or not configured (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Reset a configuration property
         * @param {string} propertyName The name of a configuration property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetConfigProperty(propertyName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetConfigProperty(propertyName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.resetConfigProperty']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Triggers the creation of a snapshot of the internal database for compatible storages.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary Trigger storage snapshot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerSnapshot(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SnapshotMetaData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.triggerSnapshot(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.triggerSnapshot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the value of a single configuration property.  This operation may fail for one of the following reasons:  * Property not found or not configured (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Update a configuration property
         * @param {string} propertyName The name of a configuration property.
         * @param {UpdateConfigurationProperty} updateConfigurationProperty 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateConfigProperty(propertyName: string, updateConfigurationProperty: UpdateConfigurationProperty, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateConfigProperty(propertyName, updateConfigurationProperty, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.updateConfigProperty']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the configuration for a globally configured rule.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Update global rule configuration
         * @param {RuleType} ruleType The unique name/type of a rule.
         * @param {Rule} rule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGlobalRuleConfig(ruleType: RuleType, rule: Rule, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGlobalRuleConfig(ruleType, rule, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.updateGlobalRuleConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a single role mapping for one user/principal.  This operation can fail for the following reasons:  * No role mapping for the principalId exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Update a role mapping
         * @param {string} principalId Unique id of a principal (typically either a user or service account).
         * @param {UpdateRole} updateRole 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRoleMapping(principalId: string, updateRole: UpdateRole, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRoleMapping(principalId, updateRole, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminApi.updateRoleMapping']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * Adds a rule to the list of globally configured rules.  This operation can fail for the following reasons:  * The rule type is unknown (HTTP error `400`) * The rule already exists (HTTP error `409`) * A server error occurred (HTTP error `500`) 
         * @summary Create global rule
         * @param {CreateRule} createRule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGlobalRule(createRule: CreateRule, options?: any): AxiosPromise<void> {
            return localVarFp.createGlobalRule(createRule, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new mapping between a user/principal and a role.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`)  
         * @summary Create a new role mapping
         * @param {RoleMapping} roleMapping 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRoleMapping(roleMapping: RoleMapping, options?: any): AxiosPromise<void> {
            return localVarFp.createRoleMapping(roleMapping, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes all globally configured rules.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary Delete all global rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllGlobalRules(options?: any): AxiosPromise<void> {
            return localVarFp.deleteAllGlobalRules(options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a single global rule.  If this is the only rule configured, this is the same as deleting **all** rules.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * Rule cannot be deleted (HTTP error `409`) * A server error occurred (HTTP error `500`) 
         * @summary Delete global rule
         * @param {RuleType} ruleType The unique name/type of a rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGlobalRule(ruleType: RuleType, options?: any): AxiosPromise<void> {
            return localVarFp.deleteGlobalRule(ruleType, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a single role mapping, effectively denying access to a user/principal.  This operation can fail for the following reasons:  * No role mapping for the principalId exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Delete a role mapping
         * @param {string} principalId Unique id of a principal (typically either a user or service account).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoleMapping(principalId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRoleMapping(principalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Exports registry data as a ZIP archive.
         * @summary Export registry data
         * @param {boolean} [forBrowser] Indicates if the operation is done for a browser.  If true, the response will be a JSON payload with a property called &#x60;href&#x60;.  This &#x60;href&#x60; will be a single-use, naked download link suitable for use by a web browser to download the content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportData(forBrowser?: boolean, options?: any): AxiosPromise<File> {
            return localVarFp.exportData(forBrowser, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the value of a single configuration property.  This operation may fail for one of the following reasons:  * Property not found or not configured (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get configuration property value
         * @param {string} propertyName The name of a configuration property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigProperty(propertyName: string, options?: any): AxiosPromise<ConfigurationProperty> {
            return localVarFp.getConfigProperty(propertyName, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about the named globally configured rule.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get global rule configuration
         * @param {RuleType} ruleType The unique name/type of a rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGlobalRuleConfig(ruleType: RuleType, options?: any): AxiosPromise<Rule> {
            return localVarFp.getGlobalRuleConfig(ruleType, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the details of a single role mapping (by `principalId`).  This operation can fail for the following reasons:  * No role mapping for the `principalId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Return a single role mapping
         * @param {string} principalId Unique id of a principal (typically either a user or service account).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleMapping(principalId: string, options?: any): AxiosPromise<RoleMapping> {
            return localVarFp.getRoleMapping(principalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Imports registry data that was previously exported using the `/admin/export` operation.
         * @summary Import registry data
         * @param {File} body The ZIP file representing the previously exported registry data.
         * @param {boolean} [xRegistryPreserveGlobalId] If this header is set to false, global ids of imported data will be ignored and replaced by next id in global id sequence. This allows to import any data even thought the global ids would cause a conflict.
         * @param {boolean} [xRegistryPreserveContentId] If this header is set to false, content ids of imported data will be ignored and replaced by next id in content id sequence. The mapping between content and artifacts will be preserved. This allows to import any data even thought the content ids would cause a conflict.
         * @param {boolean} [requireEmptyRegistry] Query parameter indicating whether the registry must be empty before allowing data to be imported.  Defaults to &#x60;true&#x60; if omitted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importData(body: File, xRegistryPreserveGlobalId?: boolean, xRegistryPreserveContentId?: boolean, requireEmptyRegistry?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.importData(body, xRegistryPreserveGlobalId, xRegistryPreserveContentId, requireEmptyRegistry, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a list of all the configured artifact types.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary List artifact types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifactTypes(options?: any): AxiosPromise<Array<ArtifactTypeInfo>> {
            return localVarFp.listArtifactTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all configuration properties that have been set.  The list is not paged.  This operation may fail for one of the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary List all configuration properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConfigProperties(options?: any): AxiosPromise<Array<ConfigurationProperty>> {
            return localVarFp.listConfigProperties(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a list of all the currently configured global rules (if any).  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary List global rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGlobalRules(options?: any): AxiosPromise<Array<RuleType>> {
            return localVarFp.listGlobalRules(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a list of all role mappings configured in the registry (if any).  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary List all role mappings
         * @param {number} [limit] The number of role mappings to return.  Defaults to 20.
         * @param {number} [offset] The number of role mappings to skip before starting the result set.  Defaults to 0.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRoleMappings(limit?: number, offset?: number, options?: any): AxiosPromise<RoleMappingSearchResults> {
            return localVarFp.listRoleMappings(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Resets the value of a single configuration property.  This will return the property to its default value (see external documentation for supported properties and their default values).  This operation may fail for one of the following reasons:  * Property not found or not configured (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Reset a configuration property
         * @param {string} propertyName The name of a configuration property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetConfigProperty(propertyName: string, options?: any): AxiosPromise<void> {
            return localVarFp.resetConfigProperty(propertyName, options).then((request) => request(axios, basePath));
        },
        /**
         * Triggers the creation of a snapshot of the internal database for compatible storages.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary Trigger storage snapshot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerSnapshot(options?: any): AxiosPromise<SnapshotMetaData> {
            return localVarFp.triggerSnapshot(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the value of a single configuration property.  This operation may fail for one of the following reasons:  * Property not found or not configured (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Update a configuration property
         * @param {string} propertyName The name of a configuration property.
         * @param {UpdateConfigurationProperty} updateConfigurationProperty 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConfigProperty(propertyName: string, updateConfigurationProperty: UpdateConfigurationProperty, options?: any): AxiosPromise<void> {
            return localVarFp.updateConfigProperty(propertyName, updateConfigurationProperty, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the configuration for a globally configured rule.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Update global rule configuration
         * @param {RuleType} ruleType The unique name/type of a rule.
         * @param {Rule} rule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGlobalRuleConfig(ruleType: RuleType, rule: Rule, options?: any): AxiosPromise<Rule> {
            return localVarFp.updateGlobalRuleConfig(ruleType, rule, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a single role mapping for one user/principal.  This operation can fail for the following reasons:  * No role mapping for the principalId exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Update a role mapping
         * @param {string} principalId Unique id of a principal (typically either a user or service account).
         * @param {UpdateRole} updateRole 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoleMapping(principalId: string, updateRole: UpdateRole, options?: any): AxiosPromise<void> {
            return localVarFp.updateRoleMapping(principalId, updateRole, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * Adds a rule to the list of globally configured rules.  This operation can fail for the following reasons:  * The rule type is unknown (HTTP error `400`) * The rule already exists (HTTP error `409`) * A server error occurred (HTTP error `500`) 
     * @summary Create global rule
     * @param {CreateRule} createRule 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public createGlobalRule(createRule: CreateRule, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).createGlobalRule(createRule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new mapping between a user/principal and a role.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`)  
     * @summary Create a new role mapping
     * @param {RoleMapping} roleMapping 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public createRoleMapping(roleMapping: RoleMapping, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).createRoleMapping(roleMapping, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes all globally configured rules.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
     * @summary Delete all global rules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteAllGlobalRules(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).deleteAllGlobalRules(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a single global rule.  If this is the only rule configured, this is the same as deleting **all** rules.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * Rule cannot be deleted (HTTP error `409`) * A server error occurred (HTTP error `500`) 
     * @summary Delete global rule
     * @param {RuleType} ruleType The unique name/type of a rule.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteGlobalRule(ruleType: RuleType, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).deleteGlobalRule(ruleType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a single role mapping, effectively denying access to a user/principal.  This operation can fail for the following reasons:  * No role mapping for the principalId exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Delete a role mapping
     * @param {string} principalId Unique id of a principal (typically either a user or service account).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public deleteRoleMapping(principalId: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).deleteRoleMapping(principalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Exports registry data as a ZIP archive.
     * @summary Export registry data
     * @param {boolean} [forBrowser] Indicates if the operation is done for a browser.  If true, the response will be a JSON payload with a property called &#x60;href&#x60;.  This &#x60;href&#x60; will be a single-use, naked download link suitable for use by a web browser to download the content.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public exportData(forBrowser?: boolean, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).exportData(forBrowser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the value of a single configuration property.  This operation may fail for one of the following reasons:  * Property not found or not configured (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Get configuration property value
     * @param {string} propertyName The name of a configuration property.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getConfigProperty(propertyName: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getConfigProperty(propertyName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information about the named globally configured rule.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Get global rule configuration
     * @param {RuleType} ruleType The unique name/type of a rule.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getGlobalRuleConfig(ruleType: RuleType, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getGlobalRuleConfig(ruleType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the details of a single role mapping (by `principalId`).  This operation can fail for the following reasons:  * No role mapping for the `principalId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Return a single role mapping
     * @param {string} principalId Unique id of a principal (typically either a user or service account).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public getRoleMapping(principalId: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).getRoleMapping(principalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Imports registry data that was previously exported using the `/admin/export` operation.
     * @summary Import registry data
     * @param {File} body The ZIP file representing the previously exported registry data.
     * @param {boolean} [xRegistryPreserveGlobalId] If this header is set to false, global ids of imported data will be ignored and replaced by next id in global id sequence. This allows to import any data even thought the global ids would cause a conflict.
     * @param {boolean} [xRegistryPreserveContentId] If this header is set to false, content ids of imported data will be ignored and replaced by next id in content id sequence. The mapping between content and artifacts will be preserved. This allows to import any data even thought the content ids would cause a conflict.
     * @param {boolean} [requireEmptyRegistry] Query parameter indicating whether the registry must be empty before allowing data to be imported.  Defaults to &#x60;true&#x60; if omitted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public importData(body: File, xRegistryPreserveGlobalId?: boolean, xRegistryPreserveContentId?: boolean, requireEmptyRegistry?: boolean, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).importData(body, xRegistryPreserveGlobalId, xRegistryPreserveContentId, requireEmptyRegistry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a list of all the configured artifact types.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
     * @summary List artifact types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public listArtifactTypes(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).listArtifactTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all configuration properties that have been set.  The list is not paged.  This operation may fail for one of the following reasons:  * A server error occurred (HTTP error `500`) 
     * @summary List all configuration properties
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public listConfigProperties(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).listConfigProperties(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a list of all the currently configured global rules (if any).  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
     * @summary List global rules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public listGlobalRules(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).listGlobalRules(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a list of all role mappings configured in the registry (if any).  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
     * @summary List all role mappings
     * @param {number} [limit] The number of role mappings to return.  Defaults to 20.
     * @param {number} [offset] The number of role mappings to skip before starting the result set.  Defaults to 0.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public listRoleMappings(limit?: number, offset?: number, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).listRoleMappings(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Resets the value of a single configuration property.  This will return the property to its default value (see external documentation for supported properties and their default values).  This operation may fail for one of the following reasons:  * Property not found or not configured (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Reset a configuration property
     * @param {string} propertyName The name of a configuration property.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public resetConfigProperty(propertyName: string, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).resetConfigProperty(propertyName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Triggers the creation of a snapshot of the internal database for compatible storages.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
     * @summary Trigger storage snapshot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public triggerSnapshot(options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).triggerSnapshot(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the value of a single configuration property.  This operation may fail for one of the following reasons:  * Property not found or not configured (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Update a configuration property
     * @param {string} propertyName The name of a configuration property.
     * @param {UpdateConfigurationProperty} updateConfigurationProperty 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateConfigProperty(propertyName: string, updateConfigurationProperty: UpdateConfigurationProperty, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).updateConfigProperty(propertyName, updateConfigurationProperty, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the configuration for a globally configured rule.  This operation can fail for the following reasons:  * Invalid rule name/type (HTTP error `400`) * No rule with name/type `rule` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Update global rule configuration
     * @param {RuleType} ruleType The unique name/type of a rule.
     * @param {Rule} rule 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateGlobalRuleConfig(ruleType: RuleType, rule: Rule, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).updateGlobalRuleConfig(ruleType, rule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a single role mapping for one user/principal.  This operation can fail for the following reasons:  * No role mapping for the principalId exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Update a role mapping
     * @param {string} principalId Unique id of a principal (typically either a user or service account).
     * @param {UpdateRole} updateRole 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public updateRoleMapping(principalId: string, updateRole: UpdateRole, options?: RawAxiosRequestConfig) {
        return AdminApiFp(this.configuration).updateRoleMapping(principalId, updateRole, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ArtifactRulesApi - axios parameter creator
 * @export
 */
export const ArtifactRulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a rule to the list of rules that get applied to the artifact when adding new versions.  All configured rules must pass to successfully add a new artifact version.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * Rule (named in the request body) is unknown (HTTP error `400`) * Rule is already configured (HTTP error `409`) * A server error occurred (HTTP error `500`)
         * @summary Create artifact rule
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {CreateRule} createRule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifactRule: async (groupId: string, artifactId: string, createRule: CreateRule, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('createArtifactRule', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('createArtifactRule', 'artifactId', artifactId)
            // verify required parameter 'createRule' is not null or undefined
            assertParamExists('createArtifactRule', 'createRule', createRule)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/rules`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a rule from the artifact.  This results in the rule no longer applying for this artifact.  If this is the only rule configured for the artifact, this is the  same as deleting **all** rules, and the globally configured rules now apply to this artifact.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No rule with this name/type is configured for this artifact (HTTP error `404`) * Invalid rule type (HTTP error `400`) * A server error occurred (HTTP error `500`)
         * @summary Delete artifact rule
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {DeleteArtifactRuleRuleTypeEnum} ruleType The unique name/type of a rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifactRule: async (groupId: string, artifactId: string, ruleType: DeleteArtifactRuleRuleTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteArtifactRule', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('deleteArtifactRule', 'artifactId', artifactId)
            // verify required parameter 'ruleType' is not null or undefined
            assertParamExists('deleteArtifactRule', 'ruleType', ruleType)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/rules/{ruleType}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"ruleType"}}`, encodeURIComponent(String(ruleType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes all of the rules configured for the artifact.  After this is done, the global rules apply to the artifact again.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary Delete artifact rules
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifactRules: async (groupId: string, artifactId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteArtifactRules', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('deleteArtifactRules', 'artifactId', artifactId)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/rules`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about a single rule configured for an artifact.  This is useful when you want to know what the current configuration settings are for a specific rule.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No rule with this name/type is configured for this artifact (HTTP error `404`) * Invalid rule type (HTTP error `400`) * A server error occurred (HTTP error `500`)
         * @summary Get artifact rule configuration
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {GetArtifactRuleConfigRuleTypeEnum} ruleType The unique name/type of a rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactRuleConfig: async (groupId: string, artifactId: string, ruleType: GetArtifactRuleConfigRuleTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getArtifactRuleConfig', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('getArtifactRuleConfig', 'artifactId', artifactId)
            // verify required parameter 'ruleType' is not null or undefined
            assertParamExists('getArtifactRuleConfig', 'ruleType', ruleType)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/rules/{ruleType}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"ruleType"}}`, encodeURIComponent(String(ruleType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all rules configured for the artifact.  The set of rules determines how the content of an artifact can evolve over time.  If no rules are configured for an artifact, then the rules configured for the group is used.  If no rules are  configured at the group level, then the set of globally configured rules are used.   If no global rules are defined, there are no restrictions on content evolution.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary List artifact rules
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifactRules: async (groupId: string, artifactId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('listArtifactRules', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('listArtifactRules', 'artifactId', artifactId)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/rules`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the configuration of a single rule for the artifact.  The configuration data is specific to each rule type, so the configuration of the `COMPATIBILITY` rule  is in a different format from the configuration of the `VALIDITY` rule.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No rule with this name/type is configured for this artifact (HTTP error `404`) * Invalid rule type (HTTP error `400`) * A server error occurred (HTTP error `500`) 
         * @summary Update artifact rule configuration
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {UpdateArtifactRuleConfigRuleTypeEnum} ruleType The unique name/type of a rule.
         * @param {Rule} rule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtifactRuleConfig: async (groupId: string, artifactId: string, ruleType: UpdateArtifactRuleConfigRuleTypeEnum, rule: Rule, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateArtifactRuleConfig', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('updateArtifactRuleConfig', 'artifactId', artifactId)
            // verify required parameter 'ruleType' is not null or undefined
            assertParamExists('updateArtifactRuleConfig', 'ruleType', ruleType)
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('updateArtifactRuleConfig', 'rule', rule)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/rules/{ruleType}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"ruleType"}}`, encodeURIComponent(String(ruleType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtifactRulesApi - functional programming interface
 * @export
 */
export const ArtifactRulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArtifactRulesApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a rule to the list of rules that get applied to the artifact when adding new versions.  All configured rules must pass to successfully add a new artifact version.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * Rule (named in the request body) is unknown (HTTP error `400`) * Rule is already configured (HTTP error `409`) * A server error occurred (HTTP error `500`)
         * @summary Create artifact rule
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {CreateRule} createRule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createArtifactRule(groupId: string, artifactId: string, createRule: CreateRule, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createArtifactRule(groupId, artifactId, createRule, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArtifactRulesApi.createArtifactRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a rule from the artifact.  This results in the rule no longer applying for this artifact.  If this is the only rule configured for the artifact, this is the  same as deleting **all** rules, and the globally configured rules now apply to this artifact.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No rule with this name/type is configured for this artifact (HTTP error `404`) * Invalid rule type (HTTP error `400`) * A server error occurred (HTTP error `500`)
         * @summary Delete artifact rule
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {DeleteArtifactRuleRuleTypeEnum} ruleType The unique name/type of a rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteArtifactRule(groupId: string, artifactId: string, ruleType: DeleteArtifactRuleRuleTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteArtifactRule(groupId, artifactId, ruleType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArtifactRulesApi.deleteArtifactRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes all of the rules configured for the artifact.  After this is done, the global rules apply to the artifact again.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary Delete artifact rules
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteArtifactRules(groupId: string, artifactId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteArtifactRules(groupId, artifactId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArtifactRulesApi.deleteArtifactRules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns information about a single rule configured for an artifact.  This is useful when you want to know what the current configuration settings are for a specific rule.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No rule with this name/type is configured for this artifact (HTTP error `404`) * Invalid rule type (HTTP error `400`) * A server error occurred (HTTP error `500`)
         * @summary Get artifact rule configuration
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {GetArtifactRuleConfigRuleTypeEnum} ruleType The unique name/type of a rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtifactRuleConfig(groupId: string, artifactId: string, ruleType: GetArtifactRuleConfigRuleTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArtifactRuleConfig(groupId, artifactId, ruleType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArtifactRulesApi.getArtifactRuleConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all rules configured for the artifact.  The set of rules determines how the content of an artifact can evolve over time.  If no rules are configured for an artifact, then the rules configured for the group is used.  If no rules are  configured at the group level, then the set of globally configured rules are used.   If no global rules are defined, there are no restrictions on content evolution.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary List artifact rules
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listArtifactRules(groupId: string, artifactId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RuleType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listArtifactRules(groupId, artifactId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArtifactRulesApi.listArtifactRules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the configuration of a single rule for the artifact.  The configuration data is specific to each rule type, so the configuration of the `COMPATIBILITY` rule  is in a different format from the configuration of the `VALIDITY` rule.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No rule with this name/type is configured for this artifact (HTTP error `404`) * Invalid rule type (HTTP error `400`) * A server error occurred (HTTP error `500`) 
         * @summary Update artifact rule configuration
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {UpdateArtifactRuleConfigRuleTypeEnum} ruleType The unique name/type of a rule.
         * @param {Rule} rule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateArtifactRuleConfig(groupId: string, artifactId: string, ruleType: UpdateArtifactRuleConfigRuleTypeEnum, rule: Rule, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateArtifactRuleConfig(groupId, artifactId, ruleType, rule, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArtifactRulesApi.updateArtifactRuleConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ArtifactRulesApi - factory interface
 * @export
 */
export const ArtifactRulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArtifactRulesApiFp(configuration)
    return {
        /**
         * Adds a rule to the list of rules that get applied to the artifact when adding new versions.  All configured rules must pass to successfully add a new artifact version.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * Rule (named in the request body) is unknown (HTTP error `400`) * Rule is already configured (HTTP error `409`) * A server error occurred (HTTP error `500`)
         * @summary Create artifact rule
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {CreateRule} createRule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifactRule(groupId: string, artifactId: string, createRule: CreateRule, options?: any): AxiosPromise<void> {
            return localVarFp.createArtifactRule(groupId, artifactId, createRule, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a rule from the artifact.  This results in the rule no longer applying for this artifact.  If this is the only rule configured for the artifact, this is the  same as deleting **all** rules, and the globally configured rules now apply to this artifact.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No rule with this name/type is configured for this artifact (HTTP error `404`) * Invalid rule type (HTTP error `400`) * A server error occurred (HTTP error `500`)
         * @summary Delete artifact rule
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {DeleteArtifactRuleRuleTypeEnum} ruleType The unique name/type of a rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifactRule(groupId: string, artifactId: string, ruleType: DeleteArtifactRuleRuleTypeEnum, options?: any): AxiosPromise<void> {
            return localVarFp.deleteArtifactRule(groupId, artifactId, ruleType, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes all of the rules configured for the artifact.  After this is done, the global rules apply to the artifact again.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary Delete artifact rules
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifactRules(groupId: string, artifactId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteArtifactRules(groupId, artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about a single rule configured for an artifact.  This is useful when you want to know what the current configuration settings are for a specific rule.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No rule with this name/type is configured for this artifact (HTTP error `404`) * Invalid rule type (HTTP error `400`) * A server error occurred (HTTP error `500`)
         * @summary Get artifact rule configuration
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {GetArtifactRuleConfigRuleTypeEnum} ruleType The unique name/type of a rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactRuleConfig(groupId: string, artifactId: string, ruleType: GetArtifactRuleConfigRuleTypeEnum, options?: any): AxiosPromise<Rule> {
            return localVarFp.getArtifactRuleConfig(groupId, artifactId, ruleType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all rules configured for the artifact.  The set of rules determines how the content of an artifact can evolve over time.  If no rules are configured for an artifact, then the rules configured for the group is used.  If no rules are  configured at the group level, then the set of globally configured rules are used.   If no global rules are defined, there are no restrictions on content evolution.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary List artifact rules
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifactRules(groupId: string, artifactId: string, options?: any): AxiosPromise<Array<RuleType>> {
            return localVarFp.listArtifactRules(groupId, artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the configuration of a single rule for the artifact.  The configuration data is specific to each rule type, so the configuration of the `COMPATIBILITY` rule  is in a different format from the configuration of the `VALIDITY` rule.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No rule with this name/type is configured for this artifact (HTTP error `404`) * Invalid rule type (HTTP error `400`) * A server error occurred (HTTP error `500`) 
         * @summary Update artifact rule configuration
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {UpdateArtifactRuleConfigRuleTypeEnum} ruleType The unique name/type of a rule.
         * @param {Rule} rule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtifactRuleConfig(groupId: string, artifactId: string, ruleType: UpdateArtifactRuleConfigRuleTypeEnum, rule: Rule, options?: any): AxiosPromise<Rule> {
            return localVarFp.updateArtifactRuleConfig(groupId, artifactId, ruleType, rule, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArtifactRulesApi - object-oriented interface
 * @export
 * @class ArtifactRulesApi
 * @extends {BaseAPI}
 */
export class ArtifactRulesApi extends BaseAPI {
    /**
     * Adds a rule to the list of rules that get applied to the artifact when adding new versions.  All configured rules must pass to successfully add a new artifact version.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * Rule (named in the request body) is unknown (HTTP error `400`) * Rule is already configured (HTTP error `409`) * A server error occurred (HTTP error `500`)
     * @summary Create artifact rule
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {CreateRule} createRule 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactRulesApi
     */
    public createArtifactRule(groupId: string, artifactId: string, createRule: CreateRule, options?: RawAxiosRequestConfig) {
        return ArtifactRulesApiFp(this.configuration).createArtifactRule(groupId, artifactId, createRule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a rule from the artifact.  This results in the rule no longer applying for this artifact.  If this is the only rule configured for the artifact, this is the  same as deleting **all** rules, and the globally configured rules now apply to this artifact.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No rule with this name/type is configured for this artifact (HTTP error `404`) * Invalid rule type (HTTP error `400`) * A server error occurred (HTTP error `500`)
     * @summary Delete artifact rule
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {DeleteArtifactRuleRuleTypeEnum} ruleType The unique name/type of a rule.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactRulesApi
     */
    public deleteArtifactRule(groupId: string, artifactId: string, ruleType: DeleteArtifactRuleRuleTypeEnum, options?: RawAxiosRequestConfig) {
        return ArtifactRulesApiFp(this.configuration).deleteArtifactRule(groupId, artifactId, ruleType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes all of the rules configured for the artifact.  After this is done, the global rules apply to the artifact again.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
     * @summary Delete artifact rules
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactRulesApi
     */
    public deleteArtifactRules(groupId: string, artifactId: string, options?: RawAxiosRequestConfig) {
        return ArtifactRulesApiFp(this.configuration).deleteArtifactRules(groupId, artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information about a single rule configured for an artifact.  This is useful when you want to know what the current configuration settings are for a specific rule.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No rule with this name/type is configured for this artifact (HTTP error `404`) * Invalid rule type (HTTP error `400`) * A server error occurred (HTTP error `500`)
     * @summary Get artifact rule configuration
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {GetArtifactRuleConfigRuleTypeEnum} ruleType The unique name/type of a rule.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactRulesApi
     */
    public getArtifactRuleConfig(groupId: string, artifactId: string, ruleType: GetArtifactRuleConfigRuleTypeEnum, options?: RawAxiosRequestConfig) {
        return ArtifactRulesApiFp(this.configuration).getArtifactRuleConfig(groupId, artifactId, ruleType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all rules configured for the artifact.  The set of rules determines how the content of an artifact can evolve over time.  If no rules are configured for an artifact, then the rules configured for the group is used.  If no rules are  configured at the group level, then the set of globally configured rules are used.   If no global rules are defined, there are no restrictions on content evolution.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
     * @summary List artifact rules
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactRulesApi
     */
    public listArtifactRules(groupId: string, artifactId: string, options?: RawAxiosRequestConfig) {
        return ArtifactRulesApiFp(this.configuration).listArtifactRules(groupId, artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the configuration of a single rule for the artifact.  The configuration data is specific to each rule type, so the configuration of the `COMPATIBILITY` rule  is in a different format from the configuration of the `VALIDITY` rule.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No rule with this name/type is configured for this artifact (HTTP error `404`) * Invalid rule type (HTTP error `400`) * A server error occurred (HTTP error `500`) 
     * @summary Update artifact rule configuration
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {UpdateArtifactRuleConfigRuleTypeEnum} ruleType The unique name/type of a rule.
     * @param {Rule} rule 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactRulesApi
     */
    public updateArtifactRuleConfig(groupId: string, artifactId: string, ruleType: UpdateArtifactRuleConfigRuleTypeEnum, rule: Rule, options?: RawAxiosRequestConfig) {
        return ArtifactRulesApiFp(this.configuration).updateArtifactRuleConfig(groupId, artifactId, ruleType, rule, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeleteArtifactRuleRuleTypeEnum = {
    Validity: 'VALIDITY',
    Compatibility: 'COMPATIBILITY',
    Integrity: 'INTEGRITY'
} as const;
export type DeleteArtifactRuleRuleTypeEnum = typeof DeleteArtifactRuleRuleTypeEnum[keyof typeof DeleteArtifactRuleRuleTypeEnum];
/**
 * @export
 */
export const GetArtifactRuleConfigRuleTypeEnum = {
    Validity: 'VALIDITY',
    Compatibility: 'COMPATIBILITY',
    Integrity: 'INTEGRITY'
} as const;
export type GetArtifactRuleConfigRuleTypeEnum = typeof GetArtifactRuleConfigRuleTypeEnum[keyof typeof GetArtifactRuleConfigRuleTypeEnum];
/**
 * @export
 */
export const UpdateArtifactRuleConfigRuleTypeEnum = {
    Validity: 'VALIDITY',
    Compatibility: 'COMPATIBILITY',
    Integrity: 'INTEGRITY'
} as const;
export type UpdateArtifactRuleConfigRuleTypeEnum = typeof UpdateArtifactRuleConfigRuleTypeEnum[keyof typeof UpdateArtifactRuleConfigRuleTypeEnum];


/**
 * ArtifactTypeApi - axios parameter creator
 * @export
 */
export const ArtifactTypeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets a list of all the configured artifact types.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary List artifact types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifactTypes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/config/artifactTypes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtifactTypeApi - functional programming interface
 * @export
 */
export const ArtifactTypeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArtifactTypeApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets a list of all the configured artifact types.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary List artifact types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listArtifactTypes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactTypeInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listArtifactTypes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArtifactTypeApi.listArtifactTypes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ArtifactTypeApi - factory interface
 * @export
 */
export const ArtifactTypeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArtifactTypeApiFp(configuration)
    return {
        /**
         * Gets a list of all the configured artifact types.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary List artifact types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifactTypes(options?: any): AxiosPromise<Array<ArtifactTypeInfo>> {
            return localVarFp.listArtifactTypes(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArtifactTypeApi - object-oriented interface
 * @export
 * @class ArtifactTypeApi
 * @extends {BaseAPI}
 */
export class ArtifactTypeApi extends BaseAPI {
    /**
     * Gets a list of all the configured artifact types.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
     * @summary List artifact types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactTypeApi
     */
    public listArtifactTypes(options?: RawAxiosRequestConfig) {
        return ArtifactTypeApiFp(this.configuration).listArtifactTypes(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ArtifactsApi - axios parameter creator
 * @export
 */
export const ArtifactsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new artifact.  The body of the request should be a `CreateArtifact`  object, which includes the metadata of the new artifact and, optionally, the  metadata and content of the first version.  If the artifact type is not provided, the registry attempts to figure out what  kind of artifact is being added from the following supported list:  * Avro (`AVRO`) * Protobuf (`PROTOBUF`) * JSON Schema (`JSON`) * Kafka Connect (`KCONNECT`) * OpenAPI (`OPENAPI`) * AsyncAPI (`ASYNCAPI`) * GraphQL (`GRAPHQL`) * Web Services Description Language (`WSDL`) * XML Schema (`XSD`)  An artifact will be created using the unique artifact ID that can optionally be  provided in the request body.  If not provided in the request, the server will generate a unique ID for the artifact.  It is typically recommended that callers provide the ID, because it is typically a meaningful identifier, and as such for most use cases should be supplied by the caller.  If an artifact with the provided artifact ID already exists, the default behavior is for the server to reject the content with a 409 error.  However, the caller can supply the `ifExists` query parameter to alter this default behavior. The `ifExists` query parameter can have one of the following values:  * `FAIL` (*default*) - server rejects the content with a 409 error * `UPDATE` - server updates the existing artifact and returns the new metadata * `RETURN` - server does not create or add content to the server, but instead  returns the metadata for the existing artifact * `RETURN_OR_UPDATE` - server returns an existing **version** that matches the  provided content if such a version exists, otherwise a new version is created  This operation may fail for one of the following reasons:  * An invalid `ArtifactType` was indicated (HTTP error `400`) * No `ArtifactType` was indicated and the server could not determine one from the content (HTTP error `400`) * Provided content (request body) was empty (HTTP error `400`) * An invalid version number was used for the optional included first version (HTTP error `400`) * An artifact with the provided ID already exists (HTTP error `409`) * The content violates one of the configured global rules (HTTP error `409`) * A server error occurred (HTTP error `500`)  Note that if the `dryRun` query parameter is set to `true`, then this operation will not actually make any changes.  Instead it will succeed or fail based on  whether it **would have worked**.  Use this option to, for example, check if an artifact is valid or if a new version passes configured compatibility checks.
         * @summary Create artifact
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {CreateArtifact} createArtifact The artifact being created.
         * @param {IfArtifactExists} [ifExists] Set this option to instruct the server on what to do if the artifact already exists.
         * @param {boolean} [canonical] Used only when the &#x60;ifExists&#x60; query parameter is set to &#x60;RETURN_OR_UPDATE&#x60;, this parameter can be set to &#x60;true&#x60; to indicate that the server should \&quot;canonicalize\&quot; the content when searching for a matching version.  The canonicalization algorithm is unique to each artifact type, but typically involves removing extra whitespace and formatting the content in a consistent manner.
         * @param {boolean} [dryRun] When set to &#x60;true&#x60;, the operation will not result in any changes. Instead, it will return a result based on whether the operation **would have succeeded**.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifact: async (groupId: string, createArtifact: CreateArtifact, ifExists?: IfArtifactExists, canonical?: boolean, dryRun?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('createArtifact', 'groupId', groupId)
            // verify required parameter 'createArtifact' is not null or undefined
            assertParamExists('createArtifact', 'createArtifact', createArtifact)
            const localVarPath = `/groups/{groupId}/artifacts`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (ifExists !== undefined) {
                localVarQueryParameter['ifExists'] = ifExists;
            }

            if (canonical !== undefined) {
                localVarQueryParameter['canonical'] = canonical;
            }

            if (dryRun !== undefined) {
                localVarQueryParameter['dryRun'] = dryRun;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createArtifact, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an artifact completely, resulting in all versions of the artifact also being deleted.  This may fail for one of the following reasons:  * No artifact with the `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary Delete artifact
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifact: async (groupId: string, artifactId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteArtifact', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('deleteArtifact', 'artifactId', artifactId)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes all of the artifacts that exist in a given group.
         * @summary Delete artifacts in group
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifactsInGroup: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteArtifactsInGroup', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/artifacts`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the content for an artifact version in the registry using its globally unique identifier.  This operation may fail for one of the following reasons:  * No artifact version with this `globalId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get artifact by global ID
         * @param {number} globalId Global identifier for an artifact version.
         * @param {HandleReferencesType} [references] Allows the user to specify how references in the content should be treated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentByGlobalId: async (globalId: number, references?: HandleReferencesType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'globalId' is not null or undefined
            assertParamExists('getContentByGlobalId', 'globalId', globalId)
            const localVarPath = `/ids/globalIds/{globalId}`
                .replace(`{${"globalId"}}`, encodeURIComponent(String(globalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (references !== undefined) {
                localVarQueryParameter['references'] = references;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the content for an artifact version in the registry using the  SHA-256 hash of the content.  This content hash may be shared by multiple artifact versions in the case where the artifact versions have identical content.  This operation may fail for one of the following reasons:  * No content with this `contentHash` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get artifact content by SHA-256 hash
         * @param {string} contentHash SHA-256 content hash for a single artifact content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentByHash: async (contentHash: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentHash' is not null or undefined
            assertParamExists('getContentByHash', 'contentHash', contentHash)
            const localVarPath = `/ids/contentHashes/{contentHash}`
                .replace(`{${"contentHash"}}`, encodeURIComponent(String(contentHash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the content for an artifact version in the registry using the unique content identifier for that content.  This content ID may be shared by multiple artifact versions in the case where the artifact versions are identical.  This operation may fail for one of the following reasons:  * No content with this `contentId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get artifact content by ID
         * @param {number} contentId Global identifier for a single artifact content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentById: async (contentId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentId' is not null or undefined
            assertParamExists('getContentById', 'contentId', contentId)
            const localVarPath = `/ids/contentIds/{contentId}`
                .replace(`{${"contentId"}}`, encodeURIComponent(String(contentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all artifacts in the group.  This list is paged.
         * @summary List artifacts in group
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {number} [limit] The number of artifacts to return.  Defaults to 20.
         * @param {number} [offset] The number of artifacts to skip before starting the result set.  Defaults to 0.
         * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
         * @param {ArtifactSortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifactsInGroup: async (groupId: string, limit?: number, offset?: number, order?: SortOrder, orderby?: ArtifactSortBy, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('listArtifactsInGroup', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/artifacts`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list containing all the artifact references using the artifact content hash.  This operation may fail for one of the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary List artifact references by hash
         * @param {string} contentHash SHA-256 content hash for a single artifact content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referencesByContentHash: async (contentHash: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentHash' is not null or undefined
            assertParamExists('referencesByContentHash', 'contentHash', contentHash)
            const localVarPath = `/ids/contentHashes/{contentHash}/references`
                .replace(`{${"contentHash"}}`, encodeURIComponent(String(contentHash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list containing all the artifact references using the artifact content ID.  This operation may fail for one of the following reasons:  * A server error occurred (HTTP error `500`)
         * @summary List artifact references by content ID
         * @param {number} contentId Global identifier for a single artifact content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referencesByContentId: async (contentId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentId' is not null or undefined
            assertParamExists('referencesByContentId', 'contentId', contentId)
            const localVarPath = `/ids/contentIds/{contentId}/references`
                .replace(`{${"contentId"}}`, encodeURIComponent(String(contentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list containing all the artifact references using the artifact global ID.  This operation may fail for one of the following reasons:  * A server error occurred (HTTP error `500`)
         * @summary List artifact references by global ID
         * @param {number} globalId Global identifier for an artifact version.
         * @param {ReferenceType} [refType] Determines the type of reference to return, either INBOUND or OUTBOUND.  Defaults to OUTBOUND.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referencesByGlobalId: async (globalId: number, refType?: ReferenceType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'globalId' is not null or undefined
            assertParamExists('referencesByGlobalId', 'globalId', globalId)
            const localVarPath = `/ids/globalIds/{globalId}/references`
                .replace(`{${"globalId"}}`, encodeURIComponent(String(globalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (refType !== undefined) {
                localVarQueryParameter['refType'] = refType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of all artifacts that match the provided filter criteria.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary Search for artifacts
         * @param {string} [name] Filter by artifact name.
         * @param {number} [offset] The number of artifacts to skip before starting to collect the result set.  Defaults to 0.
         * @param {number} [limit] The number of artifacts to return.  Defaults to 20.
         * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
         * @param {ArtifactSortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
         * @param {Array<string>} [labels] Filter by one or more name/value label.  Separate each name/value pair using a colon.  For example &#x60;labels&#x3D;foo:bar&#x60; will return only artifacts with a label named &#x60;foo&#x60; and value &#x60;bar&#x60;.
         * @param {string} [description] Filter by description.
         * @param {string} [groupId] Filter by artifact group.
         * @param {number} [globalId] Filter by globalId.
         * @param {number} [contentId] Filter by contentId.
         * @param {string} [artifactId] Filter by artifactId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchArtifacts: async (name?: string, offset?: number, limit?: number, order?: SortOrder, orderby?: ArtifactSortBy, labels?: Array<string>, description?: string, groupId?: string, globalId?: number, contentId?: number, artifactId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/artifacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }

            if (labels) {
                localVarQueryParameter['labels'] = labels;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['groupId'] = groupId;
            }

            if (globalId !== undefined) {
                localVarQueryParameter['globalId'] = globalId;
            }

            if (contentId !== undefined) {
                localVarQueryParameter['contentId'] = contentId;
            }

            if (artifactId !== undefined) {
                localVarQueryParameter['artifactId'] = artifactId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of all artifacts with at least one version that matches the posted content.  This operation can fail for the following reasons:  * Provided content (request body) was empty (HTTP error `400`) * A server error occurred (HTTP error `500`) 
         * @summary Search for artifacts by content
         * @param {File} body The content to search for.
         * @param {boolean} [canonical] Parameter that can be set to &#x60;true&#x60; to indicate that the server should \&quot;canonicalize\&quot; the content when searching for matching artifacts.  Canonicalization is unique to each artifact type, but typically involves removing any extra whitespace and formatting the content in a consistent manner.  Must be used along with the &#x60;artifactType&#x60; query parameter.
         * @param {string} [artifactType] Indicates the type of artifact represented by the content being used for the search.  This is only needed when using the &#x60;canonical&#x60; query parameter, so that the server knows how to canonicalize the content prior to searching for matching artifacts.
         * @param {string} [groupId] Filter by artifact group.
         * @param {number} [offset] The number of artifacts to skip before starting to collect the result set.  Defaults to 0.
         * @param {number} [limit] The number of artifacts to return.  Defaults to 20.
         * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
         * @param {ArtifactSortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchArtifactsByContent: async (body: File, canonical?: boolean, artifactType?: string, groupId?: string, offset?: number, limit?: number, order?: SortOrder, orderby?: ArtifactSortBy, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('searchArtifactsByContent', 'body', body)
            const localVarPath = `/search/artifacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (canonical !== undefined) {
                localVarQueryParameter['canonical'] = canonical;
            }

            if (artifactType !== undefined) {
                localVarQueryParameter['artifactType'] = artifactType;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['groupId'] = groupId;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArtifactsApi - functional programming interface
 * @export
 */
export const ArtifactsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArtifactsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new artifact.  The body of the request should be a `CreateArtifact`  object, which includes the metadata of the new artifact and, optionally, the  metadata and content of the first version.  If the artifact type is not provided, the registry attempts to figure out what  kind of artifact is being added from the following supported list:  * Avro (`AVRO`) * Protobuf (`PROTOBUF`) * JSON Schema (`JSON`) * Kafka Connect (`KCONNECT`) * OpenAPI (`OPENAPI`) * AsyncAPI (`ASYNCAPI`) * GraphQL (`GRAPHQL`) * Web Services Description Language (`WSDL`) * XML Schema (`XSD`)  An artifact will be created using the unique artifact ID that can optionally be  provided in the request body.  If not provided in the request, the server will generate a unique ID for the artifact.  It is typically recommended that callers provide the ID, because it is typically a meaningful identifier, and as such for most use cases should be supplied by the caller.  If an artifact with the provided artifact ID already exists, the default behavior is for the server to reject the content with a 409 error.  However, the caller can supply the `ifExists` query parameter to alter this default behavior. The `ifExists` query parameter can have one of the following values:  * `FAIL` (*default*) - server rejects the content with a 409 error * `UPDATE` - server updates the existing artifact and returns the new metadata * `RETURN` - server does not create or add content to the server, but instead  returns the metadata for the existing artifact * `RETURN_OR_UPDATE` - server returns an existing **version** that matches the  provided content if such a version exists, otherwise a new version is created  This operation may fail for one of the following reasons:  * An invalid `ArtifactType` was indicated (HTTP error `400`) * No `ArtifactType` was indicated and the server could not determine one from the content (HTTP error `400`) * Provided content (request body) was empty (HTTP error `400`) * An invalid version number was used for the optional included first version (HTTP error `400`) * An artifact with the provided ID already exists (HTTP error `409`) * The content violates one of the configured global rules (HTTP error `409`) * A server error occurred (HTTP error `500`)  Note that if the `dryRun` query parameter is set to `true`, then this operation will not actually make any changes.  Instead it will succeed or fail based on  whether it **would have worked**.  Use this option to, for example, check if an artifact is valid or if a new version passes configured compatibility checks.
         * @summary Create artifact
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {CreateArtifact} createArtifact The artifact being created.
         * @param {IfArtifactExists} [ifExists] Set this option to instruct the server on what to do if the artifact already exists.
         * @param {boolean} [canonical] Used only when the &#x60;ifExists&#x60; query parameter is set to &#x60;RETURN_OR_UPDATE&#x60;, this parameter can be set to &#x60;true&#x60; to indicate that the server should \&quot;canonicalize\&quot; the content when searching for a matching version.  The canonicalization algorithm is unique to each artifact type, but typically involves removing extra whitespace and formatting the content in a consistent manner.
         * @param {boolean} [dryRun] When set to &#x60;true&#x60;, the operation will not result in any changes. Instead, it will return a result based on whether the operation **would have succeeded**.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createArtifact(groupId: string, createArtifact: CreateArtifact, ifExists?: IfArtifactExists, canonical?: boolean, dryRun?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateArtifactResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createArtifact(groupId, createArtifact, ifExists, canonical, dryRun, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArtifactsApi.createArtifact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes an artifact completely, resulting in all versions of the artifact also being deleted.  This may fail for one of the following reasons:  * No artifact with the `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary Delete artifact
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteArtifact(groupId: string, artifactId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteArtifact(groupId, artifactId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArtifactsApi.deleteArtifact']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes all of the artifacts that exist in a given group.
         * @summary Delete artifacts in group
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteArtifactsInGroup(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteArtifactsInGroup(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArtifactsApi.deleteArtifactsInGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets the content for an artifact version in the registry using its globally unique identifier.  This operation may fail for one of the following reasons:  * No artifact version with this `globalId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get artifact by global ID
         * @param {number} globalId Global identifier for an artifact version.
         * @param {HandleReferencesType} [references] Allows the user to specify how references in the content should be treated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContentByGlobalId(globalId: number, references?: HandleReferencesType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContentByGlobalId(globalId, references, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArtifactsApi.getContentByGlobalId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets the content for an artifact version in the registry using the  SHA-256 hash of the content.  This content hash may be shared by multiple artifact versions in the case where the artifact versions have identical content.  This operation may fail for one of the following reasons:  * No content with this `contentHash` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get artifact content by SHA-256 hash
         * @param {string} contentHash SHA-256 content hash for a single artifact content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContentByHash(contentHash: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContentByHash(contentHash, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArtifactsApi.getContentByHash']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets the content for an artifact version in the registry using the unique content identifier for that content.  This content ID may be shared by multiple artifact versions in the case where the artifact versions are identical.  This operation may fail for one of the following reasons:  * No content with this `contentId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get artifact content by ID
         * @param {number} contentId Global identifier for a single artifact content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContentById(contentId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContentById(contentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArtifactsApi.getContentById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all artifacts in the group.  This list is paged.
         * @summary List artifacts in group
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {number} [limit] The number of artifacts to return.  Defaults to 20.
         * @param {number} [offset] The number of artifacts to skip before starting the result set.  Defaults to 0.
         * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
         * @param {ArtifactSortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listArtifactsInGroup(groupId: string, limit?: number, offset?: number, order?: SortOrder, orderby?: ArtifactSortBy, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactSearchResults>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listArtifactsInGroup(groupId, limit, offset, order, orderby, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArtifactsApi.listArtifactsInGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list containing all the artifact references using the artifact content hash.  This operation may fail for one of the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary List artifact references by hash
         * @param {string} contentHash SHA-256 content hash for a single artifact content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async referencesByContentHash(contentHash: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactReference>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.referencesByContentHash(contentHash, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArtifactsApi.referencesByContentHash']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list containing all the artifact references using the artifact content ID.  This operation may fail for one of the following reasons:  * A server error occurred (HTTP error `500`)
         * @summary List artifact references by content ID
         * @param {number} contentId Global identifier for a single artifact content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async referencesByContentId(contentId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactReference>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.referencesByContentId(contentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArtifactsApi.referencesByContentId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list containing all the artifact references using the artifact global ID.  This operation may fail for one of the following reasons:  * A server error occurred (HTTP error `500`)
         * @summary List artifact references by global ID
         * @param {number} globalId Global identifier for an artifact version.
         * @param {ReferenceType} [refType] Determines the type of reference to return, either INBOUND or OUTBOUND.  Defaults to OUTBOUND.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async referencesByGlobalId(globalId: number, refType?: ReferenceType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactReference>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.referencesByGlobalId(globalId, refType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArtifactsApi.referencesByGlobalId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of all artifacts that match the provided filter criteria.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary Search for artifacts
         * @param {string} [name] Filter by artifact name.
         * @param {number} [offset] The number of artifacts to skip before starting to collect the result set.  Defaults to 0.
         * @param {number} [limit] The number of artifacts to return.  Defaults to 20.
         * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
         * @param {ArtifactSortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
         * @param {Array<string>} [labels] Filter by one or more name/value label.  Separate each name/value pair using a colon.  For example &#x60;labels&#x3D;foo:bar&#x60; will return only artifacts with a label named &#x60;foo&#x60; and value &#x60;bar&#x60;.
         * @param {string} [description] Filter by description.
         * @param {string} [groupId] Filter by artifact group.
         * @param {number} [globalId] Filter by globalId.
         * @param {number} [contentId] Filter by contentId.
         * @param {string} [artifactId] Filter by artifactId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchArtifacts(name?: string, offset?: number, limit?: number, order?: SortOrder, orderby?: ArtifactSortBy, labels?: Array<string>, description?: string, groupId?: string, globalId?: number, contentId?: number, artifactId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactSearchResults>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchArtifacts(name, offset, limit, order, orderby, labels, description, groupId, globalId, contentId, artifactId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArtifactsApi.searchArtifacts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of all artifacts with at least one version that matches the posted content.  This operation can fail for the following reasons:  * Provided content (request body) was empty (HTTP error `400`) * A server error occurred (HTTP error `500`) 
         * @summary Search for artifacts by content
         * @param {File} body The content to search for.
         * @param {boolean} [canonical] Parameter that can be set to &#x60;true&#x60; to indicate that the server should \&quot;canonicalize\&quot; the content when searching for matching artifacts.  Canonicalization is unique to each artifact type, but typically involves removing any extra whitespace and formatting the content in a consistent manner.  Must be used along with the &#x60;artifactType&#x60; query parameter.
         * @param {string} [artifactType] Indicates the type of artifact represented by the content being used for the search.  This is only needed when using the &#x60;canonical&#x60; query parameter, so that the server knows how to canonicalize the content prior to searching for matching artifacts.
         * @param {string} [groupId] Filter by artifact group.
         * @param {number} [offset] The number of artifacts to skip before starting to collect the result set.  Defaults to 0.
         * @param {number} [limit] The number of artifacts to return.  Defaults to 20.
         * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
         * @param {ArtifactSortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchArtifactsByContent(body: File, canonical?: boolean, artifactType?: string, groupId?: string, offset?: number, limit?: number, order?: SortOrder, orderby?: ArtifactSortBy, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactSearchResults>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchArtifactsByContent(body, canonical, artifactType, groupId, offset, limit, order, orderby, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArtifactsApi.searchArtifactsByContent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ArtifactsApi - factory interface
 * @export
 */
export const ArtifactsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArtifactsApiFp(configuration)
    return {
        /**
         * Creates a new artifact.  The body of the request should be a `CreateArtifact`  object, which includes the metadata of the new artifact and, optionally, the  metadata and content of the first version.  If the artifact type is not provided, the registry attempts to figure out what  kind of artifact is being added from the following supported list:  * Avro (`AVRO`) * Protobuf (`PROTOBUF`) * JSON Schema (`JSON`) * Kafka Connect (`KCONNECT`) * OpenAPI (`OPENAPI`) * AsyncAPI (`ASYNCAPI`) * GraphQL (`GRAPHQL`) * Web Services Description Language (`WSDL`) * XML Schema (`XSD`)  An artifact will be created using the unique artifact ID that can optionally be  provided in the request body.  If not provided in the request, the server will generate a unique ID for the artifact.  It is typically recommended that callers provide the ID, because it is typically a meaningful identifier, and as such for most use cases should be supplied by the caller.  If an artifact with the provided artifact ID already exists, the default behavior is for the server to reject the content with a 409 error.  However, the caller can supply the `ifExists` query parameter to alter this default behavior. The `ifExists` query parameter can have one of the following values:  * `FAIL` (*default*) - server rejects the content with a 409 error * `UPDATE` - server updates the existing artifact and returns the new metadata * `RETURN` - server does not create or add content to the server, but instead  returns the metadata for the existing artifact * `RETURN_OR_UPDATE` - server returns an existing **version** that matches the  provided content if such a version exists, otherwise a new version is created  This operation may fail for one of the following reasons:  * An invalid `ArtifactType` was indicated (HTTP error `400`) * No `ArtifactType` was indicated and the server could not determine one from the content (HTTP error `400`) * Provided content (request body) was empty (HTTP error `400`) * An invalid version number was used for the optional included first version (HTTP error `400`) * An artifact with the provided ID already exists (HTTP error `409`) * The content violates one of the configured global rules (HTTP error `409`) * A server error occurred (HTTP error `500`)  Note that if the `dryRun` query parameter is set to `true`, then this operation will not actually make any changes.  Instead it will succeed or fail based on  whether it **would have worked**.  Use this option to, for example, check if an artifact is valid or if a new version passes configured compatibility checks.
         * @summary Create artifact
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {CreateArtifact} createArtifact The artifact being created.
         * @param {IfArtifactExists} [ifExists] Set this option to instruct the server on what to do if the artifact already exists.
         * @param {boolean} [canonical] Used only when the &#x60;ifExists&#x60; query parameter is set to &#x60;RETURN_OR_UPDATE&#x60;, this parameter can be set to &#x60;true&#x60; to indicate that the server should \&quot;canonicalize\&quot; the content when searching for a matching version.  The canonicalization algorithm is unique to each artifact type, but typically involves removing extra whitespace and formatting the content in a consistent manner.
         * @param {boolean} [dryRun] When set to &#x60;true&#x60;, the operation will not result in any changes. Instead, it will return a result based on whether the operation **would have succeeded**.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifact(groupId: string, createArtifact: CreateArtifact, ifExists?: IfArtifactExists, canonical?: boolean, dryRun?: boolean, options?: any): AxiosPromise<CreateArtifactResponse> {
            return localVarFp.createArtifact(groupId, createArtifact, ifExists, canonical, dryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an artifact completely, resulting in all versions of the artifact also being deleted.  This may fail for one of the following reasons:  * No artifact with the `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary Delete artifact
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifact(groupId: string, artifactId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteArtifact(groupId, artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes all of the artifacts that exist in a given group.
         * @summary Delete artifacts in group
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifactsInGroup(groupId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteArtifactsInGroup(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the content for an artifact version in the registry using its globally unique identifier.  This operation may fail for one of the following reasons:  * No artifact version with this `globalId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get artifact by global ID
         * @param {number} globalId Global identifier for an artifact version.
         * @param {HandleReferencesType} [references] Allows the user to specify how references in the content should be treated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentByGlobalId(globalId: number, references?: HandleReferencesType, options?: any): AxiosPromise<File> {
            return localVarFp.getContentByGlobalId(globalId, references, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the content for an artifact version in the registry using the  SHA-256 hash of the content.  This content hash may be shared by multiple artifact versions in the case where the artifact versions have identical content.  This operation may fail for one of the following reasons:  * No content with this `contentHash` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get artifact content by SHA-256 hash
         * @param {string} contentHash SHA-256 content hash for a single artifact content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentByHash(contentHash: string, options?: any): AxiosPromise<File> {
            return localVarFp.getContentByHash(contentHash, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the content for an artifact version in the registry using the unique content identifier for that content.  This content ID may be shared by multiple artifact versions in the case where the artifact versions are identical.  This operation may fail for one of the following reasons:  * No content with this `contentId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get artifact content by ID
         * @param {number} contentId Global identifier for a single artifact content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentById(contentId: number, options?: any): AxiosPromise<File> {
            return localVarFp.getContentById(contentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all artifacts in the group.  This list is paged.
         * @summary List artifacts in group
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {number} [limit] The number of artifacts to return.  Defaults to 20.
         * @param {number} [offset] The number of artifacts to skip before starting the result set.  Defaults to 0.
         * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
         * @param {ArtifactSortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifactsInGroup(groupId: string, limit?: number, offset?: number, order?: SortOrder, orderby?: ArtifactSortBy, options?: any): AxiosPromise<ArtifactSearchResults> {
            return localVarFp.listArtifactsInGroup(groupId, limit, offset, order, orderby, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list containing all the artifact references using the artifact content hash.  This operation may fail for one of the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary List artifact references by hash
         * @param {string} contentHash SHA-256 content hash for a single artifact content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referencesByContentHash(contentHash: string, options?: any): AxiosPromise<Array<ArtifactReference>> {
            return localVarFp.referencesByContentHash(contentHash, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list containing all the artifact references using the artifact content ID.  This operation may fail for one of the following reasons:  * A server error occurred (HTTP error `500`)
         * @summary List artifact references by content ID
         * @param {number} contentId Global identifier for a single artifact content.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referencesByContentId(contentId: number, options?: any): AxiosPromise<Array<ArtifactReference>> {
            return localVarFp.referencesByContentId(contentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list containing all the artifact references using the artifact global ID.  This operation may fail for one of the following reasons:  * A server error occurred (HTTP error `500`)
         * @summary List artifact references by global ID
         * @param {number} globalId Global identifier for an artifact version.
         * @param {ReferenceType} [refType] Determines the type of reference to return, either INBOUND or OUTBOUND.  Defaults to OUTBOUND.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        referencesByGlobalId(globalId: number, refType?: ReferenceType, options?: any): AxiosPromise<Array<ArtifactReference>> {
            return localVarFp.referencesByGlobalId(globalId, refType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of all artifacts that match the provided filter criteria.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary Search for artifacts
         * @param {string} [name] Filter by artifact name.
         * @param {number} [offset] The number of artifacts to skip before starting to collect the result set.  Defaults to 0.
         * @param {number} [limit] The number of artifacts to return.  Defaults to 20.
         * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
         * @param {ArtifactSortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
         * @param {Array<string>} [labels] Filter by one or more name/value label.  Separate each name/value pair using a colon.  For example &#x60;labels&#x3D;foo:bar&#x60; will return only artifacts with a label named &#x60;foo&#x60; and value &#x60;bar&#x60;.
         * @param {string} [description] Filter by description.
         * @param {string} [groupId] Filter by artifact group.
         * @param {number} [globalId] Filter by globalId.
         * @param {number} [contentId] Filter by contentId.
         * @param {string} [artifactId] Filter by artifactId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchArtifacts(name?: string, offset?: number, limit?: number, order?: SortOrder, orderby?: ArtifactSortBy, labels?: Array<string>, description?: string, groupId?: string, globalId?: number, contentId?: number, artifactId?: string, options?: any): AxiosPromise<ArtifactSearchResults> {
            return localVarFp.searchArtifacts(name, offset, limit, order, orderby, labels, description, groupId, globalId, contentId, artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of all artifacts with at least one version that matches the posted content.  This operation can fail for the following reasons:  * Provided content (request body) was empty (HTTP error `400`) * A server error occurred (HTTP error `500`) 
         * @summary Search for artifacts by content
         * @param {File} body The content to search for.
         * @param {boolean} [canonical] Parameter that can be set to &#x60;true&#x60; to indicate that the server should \&quot;canonicalize\&quot; the content when searching for matching artifacts.  Canonicalization is unique to each artifact type, but typically involves removing any extra whitespace and formatting the content in a consistent manner.  Must be used along with the &#x60;artifactType&#x60; query parameter.
         * @param {string} [artifactType] Indicates the type of artifact represented by the content being used for the search.  This is only needed when using the &#x60;canonical&#x60; query parameter, so that the server knows how to canonicalize the content prior to searching for matching artifacts.
         * @param {string} [groupId] Filter by artifact group.
         * @param {number} [offset] The number of artifacts to skip before starting to collect the result set.  Defaults to 0.
         * @param {number} [limit] The number of artifacts to return.  Defaults to 20.
         * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
         * @param {ArtifactSortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchArtifactsByContent(body: File, canonical?: boolean, artifactType?: string, groupId?: string, offset?: number, limit?: number, order?: SortOrder, orderby?: ArtifactSortBy, options?: any): AxiosPromise<ArtifactSearchResults> {
            return localVarFp.searchArtifactsByContent(body, canonical, artifactType, groupId, offset, limit, order, orderby, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ArtifactsApi - object-oriented interface
 * @export
 * @class ArtifactsApi
 * @extends {BaseAPI}
 */
export class ArtifactsApi extends BaseAPI {
    /**
     * Creates a new artifact.  The body of the request should be a `CreateArtifact`  object, which includes the metadata of the new artifact and, optionally, the  metadata and content of the first version.  If the artifact type is not provided, the registry attempts to figure out what  kind of artifact is being added from the following supported list:  * Avro (`AVRO`) * Protobuf (`PROTOBUF`) * JSON Schema (`JSON`) * Kafka Connect (`KCONNECT`) * OpenAPI (`OPENAPI`) * AsyncAPI (`ASYNCAPI`) * GraphQL (`GRAPHQL`) * Web Services Description Language (`WSDL`) * XML Schema (`XSD`)  An artifact will be created using the unique artifact ID that can optionally be  provided in the request body.  If not provided in the request, the server will generate a unique ID for the artifact.  It is typically recommended that callers provide the ID, because it is typically a meaningful identifier, and as such for most use cases should be supplied by the caller.  If an artifact with the provided artifact ID already exists, the default behavior is for the server to reject the content with a 409 error.  However, the caller can supply the `ifExists` query parameter to alter this default behavior. The `ifExists` query parameter can have one of the following values:  * `FAIL` (*default*) - server rejects the content with a 409 error * `UPDATE` - server updates the existing artifact and returns the new metadata * `RETURN` - server does not create or add content to the server, but instead  returns the metadata for the existing artifact * `RETURN_OR_UPDATE` - server returns an existing **version** that matches the  provided content if such a version exists, otherwise a new version is created  This operation may fail for one of the following reasons:  * An invalid `ArtifactType` was indicated (HTTP error `400`) * No `ArtifactType` was indicated and the server could not determine one from the content (HTTP error `400`) * Provided content (request body) was empty (HTTP error `400`) * An invalid version number was used for the optional included first version (HTTP error `400`) * An artifact with the provided ID already exists (HTTP error `409`) * The content violates one of the configured global rules (HTTP error `409`) * A server error occurred (HTTP error `500`)  Note that if the `dryRun` query parameter is set to `true`, then this operation will not actually make any changes.  Instead it will succeed or fail based on  whether it **would have worked**.  Use this option to, for example, check if an artifact is valid or if a new version passes configured compatibility checks.
     * @summary Create artifact
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {CreateArtifact} createArtifact The artifact being created.
     * @param {IfArtifactExists} [ifExists] Set this option to instruct the server on what to do if the artifact already exists.
     * @param {boolean} [canonical] Used only when the &#x60;ifExists&#x60; query parameter is set to &#x60;RETURN_OR_UPDATE&#x60;, this parameter can be set to &#x60;true&#x60; to indicate that the server should \&quot;canonicalize\&quot; the content when searching for a matching version.  The canonicalization algorithm is unique to each artifact type, but typically involves removing extra whitespace and formatting the content in a consistent manner.
     * @param {boolean} [dryRun] When set to &#x60;true&#x60;, the operation will not result in any changes. Instead, it will return a result based on whether the operation **would have succeeded**.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public createArtifact(groupId: string, createArtifact: CreateArtifact, ifExists?: IfArtifactExists, canonical?: boolean, dryRun?: boolean, options?: RawAxiosRequestConfig) {
        return ArtifactsApiFp(this.configuration).createArtifact(groupId, createArtifact, ifExists, canonical, dryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes an artifact completely, resulting in all versions of the artifact also being deleted.  This may fail for one of the following reasons:  * No artifact with the `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
     * @summary Delete artifact
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public deleteArtifact(groupId: string, artifactId: string, options?: RawAxiosRequestConfig) {
        return ArtifactsApiFp(this.configuration).deleteArtifact(groupId, artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes all of the artifacts that exist in a given group.
     * @summary Delete artifacts in group
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public deleteArtifactsInGroup(groupId: string, options?: RawAxiosRequestConfig) {
        return ArtifactsApiFp(this.configuration).deleteArtifactsInGroup(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the content for an artifact version in the registry using its globally unique identifier.  This operation may fail for one of the following reasons:  * No artifact version with this `globalId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Get artifact by global ID
     * @param {number} globalId Global identifier for an artifact version.
     * @param {HandleReferencesType} [references] Allows the user to specify how references in the content should be treated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public getContentByGlobalId(globalId: number, references?: HandleReferencesType, options?: RawAxiosRequestConfig) {
        return ArtifactsApiFp(this.configuration).getContentByGlobalId(globalId, references, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the content for an artifact version in the registry using the  SHA-256 hash of the content.  This content hash may be shared by multiple artifact versions in the case where the artifact versions have identical content.  This operation may fail for one of the following reasons:  * No content with this `contentHash` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Get artifact content by SHA-256 hash
     * @param {string} contentHash SHA-256 content hash for a single artifact content.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public getContentByHash(contentHash: string, options?: RawAxiosRequestConfig) {
        return ArtifactsApiFp(this.configuration).getContentByHash(contentHash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets the content for an artifact version in the registry using the unique content identifier for that content.  This content ID may be shared by multiple artifact versions in the case where the artifact versions are identical.  This operation may fail for one of the following reasons:  * No content with this `contentId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Get artifact content by ID
     * @param {number} contentId Global identifier for a single artifact content.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public getContentById(contentId: number, options?: RawAxiosRequestConfig) {
        return ArtifactsApiFp(this.configuration).getContentById(contentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all artifacts in the group.  This list is paged.
     * @summary List artifacts in group
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {number} [limit] The number of artifacts to return.  Defaults to 20.
     * @param {number} [offset] The number of artifacts to skip before starting the result set.  Defaults to 0.
     * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
     * @param {ArtifactSortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public listArtifactsInGroup(groupId: string, limit?: number, offset?: number, order?: SortOrder, orderby?: ArtifactSortBy, options?: RawAxiosRequestConfig) {
        return ArtifactsApiFp(this.configuration).listArtifactsInGroup(groupId, limit, offset, order, orderby, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list containing all the artifact references using the artifact content hash.  This operation may fail for one of the following reasons:  * A server error occurred (HTTP error `500`) 
     * @summary List artifact references by hash
     * @param {string} contentHash SHA-256 content hash for a single artifact content.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public referencesByContentHash(contentHash: string, options?: RawAxiosRequestConfig) {
        return ArtifactsApiFp(this.configuration).referencesByContentHash(contentHash, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list containing all the artifact references using the artifact content ID.  This operation may fail for one of the following reasons:  * A server error occurred (HTTP error `500`)
     * @summary List artifact references by content ID
     * @param {number} contentId Global identifier for a single artifact content.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public referencesByContentId(contentId: number, options?: RawAxiosRequestConfig) {
        return ArtifactsApiFp(this.configuration).referencesByContentId(contentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list containing all the artifact references using the artifact global ID.  This operation may fail for one of the following reasons:  * A server error occurred (HTTP error `500`)
     * @summary List artifact references by global ID
     * @param {number} globalId Global identifier for an artifact version.
     * @param {ReferenceType} [refType] Determines the type of reference to return, either INBOUND or OUTBOUND.  Defaults to OUTBOUND.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public referencesByGlobalId(globalId: number, refType?: ReferenceType, options?: RawAxiosRequestConfig) {
        return ArtifactsApiFp(this.configuration).referencesByGlobalId(globalId, refType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of all artifacts that match the provided filter criteria.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
     * @summary Search for artifacts
     * @param {string} [name] Filter by artifact name.
     * @param {number} [offset] The number of artifacts to skip before starting to collect the result set.  Defaults to 0.
     * @param {number} [limit] The number of artifacts to return.  Defaults to 20.
     * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
     * @param {ArtifactSortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
     * @param {Array<string>} [labels] Filter by one or more name/value label.  Separate each name/value pair using a colon.  For example &#x60;labels&#x3D;foo:bar&#x60; will return only artifacts with a label named &#x60;foo&#x60; and value &#x60;bar&#x60;.
     * @param {string} [description] Filter by description.
     * @param {string} [groupId] Filter by artifact group.
     * @param {number} [globalId] Filter by globalId.
     * @param {number} [contentId] Filter by contentId.
     * @param {string} [artifactId] Filter by artifactId.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public searchArtifacts(name?: string, offset?: number, limit?: number, order?: SortOrder, orderby?: ArtifactSortBy, labels?: Array<string>, description?: string, groupId?: string, globalId?: number, contentId?: number, artifactId?: string, options?: RawAxiosRequestConfig) {
        return ArtifactsApiFp(this.configuration).searchArtifacts(name, offset, limit, order, orderby, labels, description, groupId, globalId, contentId, artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of all artifacts with at least one version that matches the posted content.  This operation can fail for the following reasons:  * Provided content (request body) was empty (HTTP error `400`) * A server error occurred (HTTP error `500`) 
     * @summary Search for artifacts by content
     * @param {File} body The content to search for.
     * @param {boolean} [canonical] Parameter that can be set to &#x60;true&#x60; to indicate that the server should \&quot;canonicalize\&quot; the content when searching for matching artifacts.  Canonicalization is unique to each artifact type, but typically involves removing any extra whitespace and formatting the content in a consistent manner.  Must be used along with the &#x60;artifactType&#x60; query parameter.
     * @param {string} [artifactType] Indicates the type of artifact represented by the content being used for the search.  This is only needed when using the &#x60;canonical&#x60; query parameter, so that the server knows how to canonicalize the content prior to searching for matching artifacts.
     * @param {string} [groupId] Filter by artifact group.
     * @param {number} [offset] The number of artifacts to skip before starting to collect the result set.  Defaults to 0.
     * @param {number} [limit] The number of artifacts to return.  Defaults to 20.
     * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
     * @param {ArtifactSortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArtifactsApi
     */
    public searchArtifactsByContent(body: File, canonical?: boolean, artifactType?: string, groupId?: string, offset?: number, limit?: number, order?: SortOrder, orderby?: ArtifactSortBy, options?: RawAxiosRequestConfig) {
        return ArtifactsApiFp(this.configuration).searchArtifactsByContent(body, canonical, artifactType, groupId, offset, limit, order, orderby, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BranchesApi - axios parameter creator
 * @export
 */
export const BranchesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a new version to an artifact branch. Returns a list of version identifiers in the branch, ordered from the latest (tip of the branch) to the oldest.  This operation can fail for the following reasons: * No artifact with this `groupId` and `artifactId` exists (HTTP error `404`) * No branch with this `branchId` exists (HTTP error `404`) * Branch already contains the given version. Artifact branches are append-only, cycles and history rewrites, except by replacing the entire branch using the replaceBranchVersions operation,  are not supported. (HTTP error `409`) * A server error occurred (HTTP error `500`) 
         * @summary Add a new version to a branch.
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} branchId Artifact branch ID.  Must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {AddVersionToBranch} addVersionToBranch The version to add to the branch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVersionToBranch: async (groupId: string, artifactId: string, branchId: string, addVersionToBranch: AddVersionToBranch, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('addVersionToBranch', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('addVersionToBranch', 'artifactId', artifactId)
            // verify required parameter 'branchId' is not null or undefined
            assertParamExists('addVersionToBranch', 'branchId', branchId)
            // verify required parameter 'addVersionToBranch' is not null or undefined
            assertParamExists('addVersionToBranch', 'addVersionToBranch', addVersionToBranch)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/branches/{branchId}/versions`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"branchId"}}`, encodeURIComponent(String(branchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addVersionToBranch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new branch for the artifact.  A new branch consists of metadata and a list of versions.  This operation can fail for the following reasons:  * No artifact with this `groupId` and `artifactId` exists (HTTP error `404`) * A branch with the given `branchId` already exists (HTTP error `409`) * A server error occurred (HTTP error `500`) 
         * @summary Create a new branch
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {CreateBranch} createBranch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBranch: async (groupId: string, artifactId: string, createBranch: CreateBranch, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('createBranch', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('createBranch', 'artifactId', artifactId)
            // verify required parameter 'createBranch' is not null or undefined
            assertParamExists('createBranch', 'createBranch', createBranch)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/branches`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBranch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a single branch in the artifact.  This operation can fail for the following reasons: * No artifact with this `groupId` and `artifactId` exists (HTTP error `404`) * No branch with this `branchId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Delete branch.
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} branchId Artifact branch ID.  Must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBranch: async (groupId: string, artifactId: string, branchId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteBranch', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('deleteBranch', 'artifactId', artifactId)
            // verify required parameter 'branchId' is not null or undefined
            assertParamExists('deleteBranch', 'branchId', branchId)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/branches/{branchId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"branchId"}}`, encodeURIComponent(String(branchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the metaData of a branch.  This operation can fail for the following reasons:  * No artifact with this `groupId` and `artifactId` exists (HTTP error `404`) * No branch with this `branchId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get branch metaData
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} branchId Artifact branch ID.  Must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBranchMetaData: async (groupId: string, artifactId: string, branchId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getBranchMetaData', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('getBranchMetaData', 'artifactId', artifactId)
            // verify required parameter 'branchId' is not null or undefined
            assertParamExists('getBranchMetaData', 'branchId', branchId)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/branches/{branchId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"branchId"}}`, encodeURIComponent(String(branchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all versions in the branch.  Returns a list of version identifiers in the branch,  ordered from the latest (tip of the branch) to the oldest.  This operation can fail for the following reasons: * No artifact with this `groupId` and `artifactId` exists (HTTP error `404`) * No branch with this `branchId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get versions in branch
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} branchId Artifact branch ID.  Must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {number} [offset] The number of versions to skip before starting to collect the result set.  Defaults to 0.
         * @param {number} [limit] The number of versions to return.  Defaults to 20.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBranchVersions: async (groupId: string, artifactId: string, branchId: string, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('listBranchVersions', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('listBranchVersions', 'artifactId', artifactId)
            // verify required parameter 'branchId' is not null or undefined
            assertParamExists('listBranchVersions', 'branchId', branchId)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/branches/{branchId}/versions`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"branchId"}}`, encodeURIComponent(String(branchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all branches in the artifact. Each branch is a list of version identifiers, ordered from the latest (tip of the branch) to the oldest.  This operation can fail for the following reasons:  * No artifact with this `groupId` and `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary List branches
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {number} [offset] The number of branches to skip before starting to collect the result set.  Defaults to 0.
         * @param {number} [limit] The number of branches to return.  Defaults to 20.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBranches: async (groupId: string, artifactId: string, offset?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('listBranches', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('listBranches', 'artifactId', artifactId)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/branches`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a new version to an artifact branch. Branch is created if it does not exist. Returns a list of version identifiers in the artifact branch, ordered from the latest (tip of the branch) to the oldest. This operation can fail for the following reasons: * No artifact with this `groupId` and `artifactId` exists (HTTP error `404`) * No branch with this `branchId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Replace list of versions in branch
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} branchId Artifact branch ID.  Must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {ReplaceBranchVersions} replaceBranchVersions A new list of versions that should be on the branch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceBranchVersions: async (groupId: string, artifactId: string, branchId: string, replaceBranchVersions: ReplaceBranchVersions, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('replaceBranchVersions', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('replaceBranchVersions', 'artifactId', artifactId)
            // verify required parameter 'branchId' is not null or undefined
            assertParamExists('replaceBranchVersions', 'branchId', branchId)
            // verify required parameter 'replaceBranchVersions' is not null or undefined
            assertParamExists('replaceBranchVersions', 'replaceBranchVersions', replaceBranchVersions)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/branches/{branchId}/versions`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"branchId"}}`, encodeURIComponent(String(branchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(replaceBranchVersions, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the metadata of a branch.  This operation can fail for the following reasons: * No artifact with this `groupId` and `artifactId` exists (HTTP error `404`) * No branch with this `branchId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Update branch metaData
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} branchId Artifact branch ID.  Must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {EditableBranchMetaData} editableBranchMetaData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBranchMetaData: async (groupId: string, artifactId: string, branchId: string, editableBranchMetaData: EditableBranchMetaData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateBranchMetaData', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('updateBranchMetaData', 'artifactId', artifactId)
            // verify required parameter 'branchId' is not null or undefined
            assertParamExists('updateBranchMetaData', 'branchId', branchId)
            // verify required parameter 'editableBranchMetaData' is not null or undefined
            assertParamExists('updateBranchMetaData', 'editableBranchMetaData', editableBranchMetaData)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/branches/{branchId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"branchId"}}`, encodeURIComponent(String(branchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editableBranchMetaData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BranchesApi - functional programming interface
 * @export
 */
export const BranchesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BranchesApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a new version to an artifact branch. Returns a list of version identifiers in the branch, ordered from the latest (tip of the branch) to the oldest.  This operation can fail for the following reasons: * No artifact with this `groupId` and `artifactId` exists (HTTP error `404`) * No branch with this `branchId` exists (HTTP error `404`) * Branch already contains the given version. Artifact branches are append-only, cycles and history rewrites, except by replacing the entire branch using the replaceBranchVersions operation,  are not supported. (HTTP error `409`) * A server error occurred (HTTP error `500`) 
         * @summary Add a new version to a branch.
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} branchId Artifact branch ID.  Must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {AddVersionToBranch} addVersionToBranch The version to add to the branch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addVersionToBranch(groupId: string, artifactId: string, branchId: string, addVersionToBranch: AddVersionToBranch, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addVersionToBranch(groupId, artifactId, branchId, addVersionToBranch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchesApi.addVersionToBranch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new branch for the artifact.  A new branch consists of metadata and a list of versions.  This operation can fail for the following reasons:  * No artifact with this `groupId` and `artifactId` exists (HTTP error `404`) * A branch with the given `branchId` already exists (HTTP error `409`) * A server error occurred (HTTP error `500`) 
         * @summary Create a new branch
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {CreateBranch} createBranch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBranch(groupId: string, artifactId: string, createBranch: CreateBranch, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BranchMetaData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBranch(groupId, artifactId, createBranch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchesApi.createBranch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a single branch in the artifact.  This operation can fail for the following reasons: * No artifact with this `groupId` and `artifactId` exists (HTTP error `404`) * No branch with this `branchId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Delete branch.
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} branchId Artifact branch ID.  Must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBranch(groupId: string, artifactId: string, branchId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBranch(groupId, artifactId, branchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchesApi.deleteBranch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the metaData of a branch.  This operation can fail for the following reasons:  * No artifact with this `groupId` and `artifactId` exists (HTTP error `404`) * No branch with this `branchId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get branch metaData
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} branchId Artifact branch ID.  Must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBranchMetaData(groupId: string, artifactId: string, branchId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BranchMetaData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBranchMetaData(groupId, artifactId, branchId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchesApi.getBranchMetaData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of all versions in the branch.  Returns a list of version identifiers in the branch,  ordered from the latest (tip of the branch) to the oldest.  This operation can fail for the following reasons: * No artifact with this `groupId` and `artifactId` exists (HTTP error `404`) * No branch with this `branchId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get versions in branch
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} branchId Artifact branch ID.  Must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {number} [offset] The number of versions to skip before starting to collect the result set.  Defaults to 0.
         * @param {number} [limit] The number of versions to return.  Defaults to 20.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBranchVersions(groupId: string, artifactId: string, branchId: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionSearchResults>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBranchVersions(groupId, artifactId, branchId, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchesApi.listBranchVersions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all branches in the artifact. Each branch is a list of version identifiers, ordered from the latest (tip of the branch) to the oldest.  This operation can fail for the following reasons:  * No artifact with this `groupId` and `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary List branches
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {number} [offset] The number of branches to skip before starting to collect the result set.  Defaults to 0.
         * @param {number} [limit] The number of branches to return.  Defaults to 20.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBranches(groupId: string, artifactId: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BranchSearchResults>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBranches(groupId, artifactId, offset, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchesApi.listBranches']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Add a new version to an artifact branch. Branch is created if it does not exist. Returns a list of version identifiers in the artifact branch, ordered from the latest (tip of the branch) to the oldest. This operation can fail for the following reasons: * No artifact with this `groupId` and `artifactId` exists (HTTP error `404`) * No branch with this `branchId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Replace list of versions in branch
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} branchId Artifact branch ID.  Must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {ReplaceBranchVersions} replaceBranchVersions A new list of versions that should be on the branch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async replaceBranchVersions(groupId: string, artifactId: string, branchId: string, replaceBranchVersions: ReplaceBranchVersions, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.replaceBranchVersions(groupId, artifactId, branchId, replaceBranchVersions, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchesApi.replaceBranchVersions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the metadata of a branch.  This operation can fail for the following reasons: * No artifact with this `groupId` and `artifactId` exists (HTTP error `404`) * No branch with this `branchId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Update branch metaData
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} branchId Artifact branch ID.  Must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {EditableBranchMetaData} editableBranchMetaData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBranchMetaData(groupId: string, artifactId: string, branchId: string, editableBranchMetaData: EditableBranchMetaData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBranchMetaData(groupId, artifactId, branchId, editableBranchMetaData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BranchesApi.updateBranchMetaData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BranchesApi - factory interface
 * @export
 */
export const BranchesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BranchesApiFp(configuration)
    return {
        /**
         * Add a new version to an artifact branch. Returns a list of version identifiers in the branch, ordered from the latest (tip of the branch) to the oldest.  This operation can fail for the following reasons: * No artifact with this `groupId` and `artifactId` exists (HTTP error `404`) * No branch with this `branchId` exists (HTTP error `404`) * Branch already contains the given version. Artifact branches are append-only, cycles and history rewrites, except by replacing the entire branch using the replaceBranchVersions operation,  are not supported. (HTTP error `409`) * A server error occurred (HTTP error `500`) 
         * @summary Add a new version to a branch.
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} branchId Artifact branch ID.  Must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {AddVersionToBranch} addVersionToBranch The version to add to the branch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVersionToBranch(groupId: string, artifactId: string, branchId: string, addVersionToBranch: AddVersionToBranch, options?: any): AxiosPromise<void> {
            return localVarFp.addVersionToBranch(groupId, artifactId, branchId, addVersionToBranch, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new branch for the artifact.  A new branch consists of metadata and a list of versions.  This operation can fail for the following reasons:  * No artifact with this `groupId` and `artifactId` exists (HTTP error `404`) * A branch with the given `branchId` already exists (HTTP error `409`) * A server error occurred (HTTP error `500`) 
         * @summary Create a new branch
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {CreateBranch} createBranch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBranch(groupId: string, artifactId: string, createBranch: CreateBranch, options?: any): AxiosPromise<BranchMetaData> {
            return localVarFp.createBranch(groupId, artifactId, createBranch, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a single branch in the artifact.  This operation can fail for the following reasons: * No artifact with this `groupId` and `artifactId` exists (HTTP error `404`) * No branch with this `branchId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Delete branch.
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} branchId Artifact branch ID.  Must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBranch(groupId: string, artifactId: string, branchId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteBranch(groupId, artifactId, branchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the metaData of a branch.  This operation can fail for the following reasons:  * No artifact with this `groupId` and `artifactId` exists (HTTP error `404`) * No branch with this `branchId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get branch metaData
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} branchId Artifact branch ID.  Must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBranchMetaData(groupId: string, artifactId: string, branchId: string, options?: any): AxiosPromise<BranchMetaData> {
            return localVarFp.getBranchMetaData(groupId, artifactId, branchId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all versions in the branch.  Returns a list of version identifiers in the branch,  ordered from the latest (tip of the branch) to the oldest.  This operation can fail for the following reasons: * No artifact with this `groupId` and `artifactId` exists (HTTP error `404`) * No branch with this `branchId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get versions in branch
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} branchId Artifact branch ID.  Must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {number} [offset] The number of versions to skip before starting to collect the result set.  Defaults to 0.
         * @param {number} [limit] The number of versions to return.  Defaults to 20.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBranchVersions(groupId: string, artifactId: string, branchId: string, offset?: number, limit?: number, options?: any): AxiosPromise<VersionSearchResults> {
            return localVarFp.listBranchVersions(groupId, artifactId, branchId, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all branches in the artifact. Each branch is a list of version identifiers, ordered from the latest (tip of the branch) to the oldest.  This operation can fail for the following reasons:  * No artifact with this `groupId` and `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary List branches
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {number} [offset] The number of branches to skip before starting to collect the result set.  Defaults to 0.
         * @param {number} [limit] The number of branches to return.  Defaults to 20.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBranches(groupId: string, artifactId: string, offset?: number, limit?: number, options?: any): AxiosPromise<BranchSearchResults> {
            return localVarFp.listBranches(groupId, artifactId, offset, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a new version to an artifact branch. Branch is created if it does not exist. Returns a list of version identifiers in the artifact branch, ordered from the latest (tip of the branch) to the oldest. This operation can fail for the following reasons: * No artifact with this `groupId` and `artifactId` exists (HTTP error `404`) * No branch with this `branchId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Replace list of versions in branch
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} branchId Artifact branch ID.  Must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {ReplaceBranchVersions} replaceBranchVersions A new list of versions that should be on the branch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceBranchVersions(groupId: string, artifactId: string, branchId: string, replaceBranchVersions: ReplaceBranchVersions, options?: any): AxiosPromise<void> {
            return localVarFp.replaceBranchVersions(groupId, artifactId, branchId, replaceBranchVersions, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the metadata of a branch.  This operation can fail for the following reasons: * No artifact with this `groupId` and `artifactId` exists (HTTP error `404`) * No branch with this `branchId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Update branch metaData
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} branchId Artifact branch ID.  Must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {EditableBranchMetaData} editableBranchMetaData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBranchMetaData(groupId: string, artifactId: string, branchId: string, editableBranchMetaData: EditableBranchMetaData, options?: any): AxiosPromise<void> {
            return localVarFp.updateBranchMetaData(groupId, artifactId, branchId, editableBranchMetaData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BranchesApi - object-oriented interface
 * @export
 * @class BranchesApi
 * @extends {BaseAPI}
 */
export class BranchesApi extends BaseAPI {
    /**
     * Add a new version to an artifact branch. Returns a list of version identifiers in the branch, ordered from the latest (tip of the branch) to the oldest.  This operation can fail for the following reasons: * No artifact with this `groupId` and `artifactId` exists (HTTP error `404`) * No branch with this `branchId` exists (HTTP error `404`) * Branch already contains the given version. Artifact branches are append-only, cycles and history rewrites, except by replacing the entire branch using the replaceBranchVersions operation,  are not supported. (HTTP error `409`) * A server error occurred (HTTP error `500`) 
     * @summary Add a new version to a branch.
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} branchId Artifact branch ID.  Must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
     * @param {AddVersionToBranch} addVersionToBranch The version to add to the branch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApi
     */
    public addVersionToBranch(groupId: string, artifactId: string, branchId: string, addVersionToBranch: AddVersionToBranch, options?: RawAxiosRequestConfig) {
        return BranchesApiFp(this.configuration).addVersionToBranch(groupId, artifactId, branchId, addVersionToBranch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new branch for the artifact.  A new branch consists of metadata and a list of versions.  This operation can fail for the following reasons:  * No artifact with this `groupId` and `artifactId` exists (HTTP error `404`) * A branch with the given `branchId` already exists (HTTP error `409`) * A server error occurred (HTTP error `500`) 
     * @summary Create a new branch
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {CreateBranch} createBranch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApi
     */
    public createBranch(groupId: string, artifactId: string, createBranch: CreateBranch, options?: RawAxiosRequestConfig) {
        return BranchesApiFp(this.configuration).createBranch(groupId, artifactId, createBranch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a single branch in the artifact.  This operation can fail for the following reasons: * No artifact with this `groupId` and `artifactId` exists (HTTP error `404`) * No branch with this `branchId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Delete branch.
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} branchId Artifact branch ID.  Must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApi
     */
    public deleteBranch(groupId: string, artifactId: string, branchId: string, options?: RawAxiosRequestConfig) {
        return BranchesApiFp(this.configuration).deleteBranch(groupId, artifactId, branchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the metaData of a branch.  This operation can fail for the following reasons:  * No artifact with this `groupId` and `artifactId` exists (HTTP error `404`) * No branch with this `branchId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Get branch metaData
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} branchId Artifact branch ID.  Must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApi
     */
    public getBranchMetaData(groupId: string, artifactId: string, branchId: string, options?: RawAxiosRequestConfig) {
        return BranchesApiFp(this.configuration).getBranchMetaData(groupId, artifactId, branchId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all versions in the branch.  Returns a list of version identifiers in the branch,  ordered from the latest (tip of the branch) to the oldest.  This operation can fail for the following reasons: * No artifact with this `groupId` and `artifactId` exists (HTTP error `404`) * No branch with this `branchId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Get versions in branch
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} branchId Artifact branch ID.  Must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
     * @param {number} [offset] The number of versions to skip before starting to collect the result set.  Defaults to 0.
     * @param {number} [limit] The number of versions to return.  Defaults to 20.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApi
     */
    public listBranchVersions(groupId: string, artifactId: string, branchId: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return BranchesApiFp(this.configuration).listBranchVersions(groupId, artifactId, branchId, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all branches in the artifact. Each branch is a list of version identifiers, ordered from the latest (tip of the branch) to the oldest.  This operation can fail for the following reasons:  * No artifact with this `groupId` and `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary List branches
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {number} [offset] The number of branches to skip before starting to collect the result set.  Defaults to 0.
     * @param {number} [limit] The number of branches to return.  Defaults to 20.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApi
     */
    public listBranches(groupId: string, artifactId: string, offset?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return BranchesApiFp(this.configuration).listBranches(groupId, artifactId, offset, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a new version to an artifact branch. Branch is created if it does not exist. Returns a list of version identifiers in the artifact branch, ordered from the latest (tip of the branch) to the oldest. This operation can fail for the following reasons: * No artifact with this `groupId` and `artifactId` exists (HTTP error `404`) * No branch with this `branchId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Replace list of versions in branch
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} branchId Artifact branch ID.  Must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
     * @param {ReplaceBranchVersions} replaceBranchVersions A new list of versions that should be on the branch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApi
     */
    public replaceBranchVersions(groupId: string, artifactId: string, branchId: string, replaceBranchVersions: ReplaceBranchVersions, options?: RawAxiosRequestConfig) {
        return BranchesApiFp(this.configuration).replaceBranchVersions(groupId, artifactId, branchId, replaceBranchVersions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the metadata of a branch.  This operation can fail for the following reasons: * No artifact with this `groupId` and `artifactId` exists (HTTP error `404`) * No branch with this `branchId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Update branch metaData
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} branchId Artifact branch ID.  Must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
     * @param {EditableBranchMetaData} editableBranchMetaData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BranchesApi
     */
    public updateBranchMetaData(groupId: string, artifactId: string, branchId: string, editableBranchMetaData: EditableBranchMetaData, options?: RawAxiosRequestConfig) {
        return BranchesApiFp(this.configuration).updateBranchMetaData(groupId, artifactId, branchId, editableBranchMetaData, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * GroupRulesApi - axios parameter creator
 * @export
 */
export const GroupRulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a rule to the list of rules that get applied to an artifact in the group when adding new versions.  All configured rules must pass to successfully add a new artifact version.  This operation can fail for the following reasons:  * No group with this `groupId` exists (HTTP error `404`) * Rule (named in the request body) is unknown (HTTP error `400`) * Rule is already configured (HTTP error `409`) * A server error occurred (HTTP error `500`)
         * @summary Create group rule
         * @param {string} groupId The group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {CreateRule} createRule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupRule: async (groupId: string, createRule: CreateRule, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('createGroupRule', 'groupId', groupId)
            // verify required parameter 'createRule' is not null or undefined
            assertParamExists('createGroupRule', 'createRule', createRule)
            const localVarPath = `/groups/{groupId}/rules`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createRule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a rule from the group.  This results in the rule no longer applying for this group.  If this is the only rule configured for the group, this is the  same as deleting **all** rules, and the globally configured rules now apply to this group.  This operation can fail for the following reasons:  * No group with this `groupId` exists (HTTP error `404`) * No rule with this name/type is configured for this group (HTTP error `404`) * Invalid rule type (HTTP error `400`) * A server error occurred (HTTP error `500`)
         * @summary Delete group rule
         * @param {string} groupId The group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {DeleteGroupRuleRuleTypeEnum} ruleType The unique name/type of a rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupRule: async (groupId: string, ruleType: DeleteGroupRuleRuleTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteGroupRule', 'groupId', groupId)
            // verify required parameter 'ruleType' is not null or undefined
            assertParamExists('deleteGroupRule', 'ruleType', ruleType)
            const localVarPath = `/groups/{groupId}/rules/{ruleType}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"ruleType"}}`, encodeURIComponent(String(ruleType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes all of the rules configured for the group.  After this is done, the global rules apply to artifacts in the group again.  This operation can fail for the following reasons:  * No group with this `groupId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary Delete group rules
         * @param {string} groupId The group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupRules: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteGroupRules', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/rules`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns information about a single rule configured for a group.  This is useful when you want to know what the current configuration settings are for a specific rule.  This operation can fail for the following reasons:  * No group with this `groupId` exists (HTTP error `404`) * No rule with this name/type is configured for this artifact (HTTP error `404`) * Invalid rule type (HTTP error `400`) * A server error occurred (HTTP error `500`)
         * @summary Get group rule configuration
         * @param {string} groupId The group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {GetGroupRuleConfigRuleTypeEnum} ruleType The unique name/type of a rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupRuleConfig: async (groupId: string, ruleType: GetGroupRuleConfigRuleTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getGroupRuleConfig', 'groupId', groupId)
            // verify required parameter 'ruleType' is not null or undefined
            assertParamExists('getGroupRuleConfig', 'ruleType', ruleType)
            const localVarPath = `/groups/{groupId}/rules/{ruleType}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"ruleType"}}`, encodeURIComponent(String(ruleType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all rules configured for the group.  The set of rules determines how the content of an artifact in the group can evolve over time.  If no rules are  configured for a group, the set of globally configured rules are used.  This operation can fail for the following reasons:  * No group with this `groupId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary List group rules
         * @param {string} groupId The group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroupRules: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('listGroupRules', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}/rules`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the configuration of a single rule for the group.  The configuration data is specific to each rule type, so the configuration of the `COMPATIBILITY` rule  is in a different format from the configuration of the `VALIDITY` rule.  This operation can fail for the following reasons:  * No group with this `groupId` exists (HTTP error `404`) * No rule with this name/type is configured for this artifact (HTTP error `404`) * Invalid rule type (HTTP error `400`) * A server error occurred (HTTP error `500`) 
         * @summary Update group rule configuration
         * @param {string} groupId The group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {UpdateGroupRuleConfigRuleTypeEnum} ruleType The unique name/type of a rule.
         * @param {Rule} rule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupRuleConfig: async (groupId: string, ruleType: UpdateGroupRuleConfigRuleTypeEnum, rule: Rule, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateGroupRuleConfig', 'groupId', groupId)
            // verify required parameter 'ruleType' is not null or undefined
            assertParamExists('updateGroupRuleConfig', 'ruleType', ruleType)
            // verify required parameter 'rule' is not null or undefined
            assertParamExists('updateGroupRuleConfig', 'rule', rule)
            const localVarPath = `/groups/{groupId}/rules/{ruleType}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"ruleType"}}`, encodeURIComponent(String(ruleType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupRulesApi - functional programming interface
 * @export
 */
export const GroupRulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupRulesApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a rule to the list of rules that get applied to an artifact in the group when adding new versions.  All configured rules must pass to successfully add a new artifact version.  This operation can fail for the following reasons:  * No group with this `groupId` exists (HTTP error `404`) * Rule (named in the request body) is unknown (HTTP error `400`) * Rule is already configured (HTTP error `409`) * A server error occurred (HTTP error `500`)
         * @summary Create group rule
         * @param {string} groupId The group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {CreateRule} createRule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroupRule(groupId: string, createRule: CreateRule, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroupRule(groupId, createRule, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupRulesApi.createGroupRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a rule from the group.  This results in the rule no longer applying for this group.  If this is the only rule configured for the group, this is the  same as deleting **all** rules, and the globally configured rules now apply to this group.  This operation can fail for the following reasons:  * No group with this `groupId` exists (HTTP error `404`) * No rule with this name/type is configured for this group (HTTP error `404`) * Invalid rule type (HTTP error `400`) * A server error occurred (HTTP error `500`)
         * @summary Delete group rule
         * @param {string} groupId The group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {DeleteGroupRuleRuleTypeEnum} ruleType The unique name/type of a rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroupRule(groupId: string, ruleType: DeleteGroupRuleRuleTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroupRule(groupId, ruleType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupRulesApi.deleteGroupRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes all of the rules configured for the group.  After this is done, the global rules apply to artifacts in the group again.  This operation can fail for the following reasons:  * No group with this `groupId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary Delete group rules
         * @param {string} groupId The group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroupRules(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroupRules(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupRulesApi.deleteGroupRules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns information about a single rule configured for a group.  This is useful when you want to know what the current configuration settings are for a specific rule.  This operation can fail for the following reasons:  * No group with this `groupId` exists (HTTP error `404`) * No rule with this name/type is configured for this artifact (HTTP error `404`) * Invalid rule type (HTTP error `400`) * A server error occurred (HTTP error `500`)
         * @summary Get group rule configuration
         * @param {string} groupId The group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {GetGroupRuleConfigRuleTypeEnum} ruleType The unique name/type of a rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupRuleConfig(groupId: string, ruleType: GetGroupRuleConfigRuleTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupRuleConfig(groupId, ruleType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupRulesApi.getGroupRuleConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all rules configured for the group.  The set of rules determines how the content of an artifact in the group can evolve over time.  If no rules are  configured for a group, the set of globally configured rules are used.  This operation can fail for the following reasons:  * No group with this `groupId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary List group rules
         * @param {string} groupId The group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGroupRules(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RuleType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGroupRules(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupRulesApi.listGroupRules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the configuration of a single rule for the group.  The configuration data is specific to each rule type, so the configuration of the `COMPATIBILITY` rule  is in a different format from the configuration of the `VALIDITY` rule.  This operation can fail for the following reasons:  * No group with this `groupId` exists (HTTP error `404`) * No rule with this name/type is configured for this artifact (HTTP error `404`) * Invalid rule type (HTTP error `400`) * A server error occurred (HTTP error `500`) 
         * @summary Update group rule configuration
         * @param {string} groupId The group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {UpdateGroupRuleConfigRuleTypeEnum} ruleType The unique name/type of a rule.
         * @param {Rule} rule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroupRuleConfig(groupId: string, ruleType: UpdateGroupRuleConfigRuleTypeEnum, rule: Rule, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroupRuleConfig(groupId, ruleType, rule, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupRulesApi.updateGroupRuleConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GroupRulesApi - factory interface
 * @export
 */
export const GroupRulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupRulesApiFp(configuration)
    return {
        /**
         * Adds a rule to the list of rules that get applied to an artifact in the group when adding new versions.  All configured rules must pass to successfully add a new artifact version.  This operation can fail for the following reasons:  * No group with this `groupId` exists (HTTP error `404`) * Rule (named in the request body) is unknown (HTTP error `400`) * Rule is already configured (HTTP error `409`) * A server error occurred (HTTP error `500`)
         * @summary Create group rule
         * @param {string} groupId The group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {CreateRule} createRule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroupRule(groupId: string, createRule: CreateRule, options?: any): AxiosPromise<void> {
            return localVarFp.createGroupRule(groupId, createRule, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a rule from the group.  This results in the rule no longer applying for this group.  If this is the only rule configured for the group, this is the  same as deleting **all** rules, and the globally configured rules now apply to this group.  This operation can fail for the following reasons:  * No group with this `groupId` exists (HTTP error `404`) * No rule with this name/type is configured for this group (HTTP error `404`) * Invalid rule type (HTTP error `400`) * A server error occurred (HTTP error `500`)
         * @summary Delete group rule
         * @param {string} groupId The group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {DeleteGroupRuleRuleTypeEnum} ruleType The unique name/type of a rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupRule(groupId: string, ruleType: DeleteGroupRuleRuleTypeEnum, options?: any): AxiosPromise<void> {
            return localVarFp.deleteGroupRule(groupId, ruleType, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes all of the rules configured for the group.  After this is done, the global rules apply to artifacts in the group again.  This operation can fail for the following reasons:  * No group with this `groupId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary Delete group rules
         * @param {string} groupId The group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupRules(groupId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteGroupRules(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns information about a single rule configured for a group.  This is useful when you want to know what the current configuration settings are for a specific rule.  This operation can fail for the following reasons:  * No group with this `groupId` exists (HTTP error `404`) * No rule with this name/type is configured for this artifact (HTTP error `404`) * Invalid rule type (HTTP error `400`) * A server error occurred (HTTP error `500`)
         * @summary Get group rule configuration
         * @param {string} groupId The group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {GetGroupRuleConfigRuleTypeEnum} ruleType The unique name/type of a rule.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupRuleConfig(groupId: string, ruleType: GetGroupRuleConfigRuleTypeEnum, options?: any): AxiosPromise<Rule> {
            return localVarFp.getGroupRuleConfig(groupId, ruleType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all rules configured for the group.  The set of rules determines how the content of an artifact in the group can evolve over time.  If no rules are  configured for a group, the set of globally configured rules are used.  This operation can fail for the following reasons:  * No group with this `groupId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary List group rules
         * @param {string} groupId The group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroupRules(groupId: string, options?: any): AxiosPromise<Array<RuleType>> {
            return localVarFp.listGroupRules(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the configuration of a single rule for the group.  The configuration data is specific to each rule type, so the configuration of the `COMPATIBILITY` rule  is in a different format from the configuration of the `VALIDITY` rule.  This operation can fail for the following reasons:  * No group with this `groupId` exists (HTTP error `404`) * No rule with this name/type is configured for this artifact (HTTP error `404`) * Invalid rule type (HTTP error `400`) * A server error occurred (HTTP error `500`) 
         * @summary Update group rule configuration
         * @param {string} groupId The group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {UpdateGroupRuleConfigRuleTypeEnum} ruleType The unique name/type of a rule.
         * @param {Rule} rule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupRuleConfig(groupId: string, ruleType: UpdateGroupRuleConfigRuleTypeEnum, rule: Rule, options?: any): AxiosPromise<Rule> {
            return localVarFp.updateGroupRuleConfig(groupId, ruleType, rule, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupRulesApi - object-oriented interface
 * @export
 * @class GroupRulesApi
 * @extends {BaseAPI}
 */
export class GroupRulesApi extends BaseAPI {
    /**
     * Adds a rule to the list of rules that get applied to an artifact in the group when adding new versions.  All configured rules must pass to successfully add a new artifact version.  This operation can fail for the following reasons:  * No group with this `groupId` exists (HTTP error `404`) * Rule (named in the request body) is unknown (HTTP error `400`) * Rule is already configured (HTTP error `409`) * A server error occurred (HTTP error `500`)
     * @summary Create group rule
     * @param {string} groupId The group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {CreateRule} createRule 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupRulesApi
     */
    public createGroupRule(groupId: string, createRule: CreateRule, options?: RawAxiosRequestConfig) {
        return GroupRulesApiFp(this.configuration).createGroupRule(groupId, createRule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a rule from the group.  This results in the rule no longer applying for this group.  If this is the only rule configured for the group, this is the  same as deleting **all** rules, and the globally configured rules now apply to this group.  This operation can fail for the following reasons:  * No group with this `groupId` exists (HTTP error `404`) * No rule with this name/type is configured for this group (HTTP error `404`) * Invalid rule type (HTTP error `400`) * A server error occurred (HTTP error `500`)
     * @summary Delete group rule
     * @param {string} groupId The group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {DeleteGroupRuleRuleTypeEnum} ruleType The unique name/type of a rule.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupRulesApi
     */
    public deleteGroupRule(groupId: string, ruleType: DeleteGroupRuleRuleTypeEnum, options?: RawAxiosRequestConfig) {
        return GroupRulesApiFp(this.configuration).deleteGroupRule(groupId, ruleType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes all of the rules configured for the group.  After this is done, the global rules apply to artifacts in the group again.  This operation can fail for the following reasons:  * No group with this `groupId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
     * @summary Delete group rules
     * @param {string} groupId The group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupRulesApi
     */
    public deleteGroupRules(groupId: string, options?: RawAxiosRequestConfig) {
        return GroupRulesApiFp(this.configuration).deleteGroupRules(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns information about a single rule configured for a group.  This is useful when you want to know what the current configuration settings are for a specific rule.  This operation can fail for the following reasons:  * No group with this `groupId` exists (HTTP error `404`) * No rule with this name/type is configured for this artifact (HTTP error `404`) * Invalid rule type (HTTP error `400`) * A server error occurred (HTTP error `500`)
     * @summary Get group rule configuration
     * @param {string} groupId The group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {GetGroupRuleConfigRuleTypeEnum} ruleType The unique name/type of a rule.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupRulesApi
     */
    public getGroupRuleConfig(groupId: string, ruleType: GetGroupRuleConfigRuleTypeEnum, options?: RawAxiosRequestConfig) {
        return GroupRulesApiFp(this.configuration).getGroupRuleConfig(groupId, ruleType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all rules configured for the group.  The set of rules determines how the content of an artifact in the group can evolve over time.  If no rules are  configured for a group, the set of globally configured rules are used.  This operation can fail for the following reasons:  * No group with this `groupId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
     * @summary List group rules
     * @param {string} groupId The group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupRulesApi
     */
    public listGroupRules(groupId: string, options?: RawAxiosRequestConfig) {
        return GroupRulesApiFp(this.configuration).listGroupRules(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the configuration of a single rule for the group.  The configuration data is specific to each rule type, so the configuration of the `COMPATIBILITY` rule  is in a different format from the configuration of the `VALIDITY` rule.  This operation can fail for the following reasons:  * No group with this `groupId` exists (HTTP error `404`) * No rule with this name/type is configured for this artifact (HTTP error `404`) * Invalid rule type (HTTP error `400`) * A server error occurred (HTTP error `500`) 
     * @summary Update group rule configuration
     * @param {string} groupId The group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {UpdateGroupRuleConfigRuleTypeEnum} ruleType The unique name/type of a rule.
     * @param {Rule} rule 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupRulesApi
     */
    public updateGroupRuleConfig(groupId: string, ruleType: UpdateGroupRuleConfigRuleTypeEnum, rule: Rule, options?: RawAxiosRequestConfig) {
        return GroupRulesApiFp(this.configuration).updateGroupRuleConfig(groupId, ruleType, rule, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeleteGroupRuleRuleTypeEnum = {
    Validity: 'VALIDITY',
    Compatibility: 'COMPATIBILITY',
    Integrity: 'INTEGRITY'
} as const;
export type DeleteGroupRuleRuleTypeEnum = typeof DeleteGroupRuleRuleTypeEnum[keyof typeof DeleteGroupRuleRuleTypeEnum];
/**
 * @export
 */
export const GetGroupRuleConfigRuleTypeEnum = {
    Validity: 'VALIDITY',
    Compatibility: 'COMPATIBILITY',
    Integrity: 'INTEGRITY'
} as const;
export type GetGroupRuleConfigRuleTypeEnum = typeof GetGroupRuleConfigRuleTypeEnum[keyof typeof GetGroupRuleConfigRuleTypeEnum];
/**
 * @export
 */
export const UpdateGroupRuleConfigRuleTypeEnum = {
    Validity: 'VALIDITY',
    Compatibility: 'COMPATIBILITY',
    Integrity: 'INTEGRITY'
} as const;
export type UpdateGroupRuleConfigRuleTypeEnum = typeof UpdateGroupRuleConfigRuleTypeEnum[keyof typeof UpdateGroupRuleConfigRuleTypeEnum];


/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new group.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) * The group already exist (HTTP error `409`) 
         * @summary Create a new group
         * @param {CreateGroup} createGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup: async (createGroup: CreateGroup, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createGroup' is not null or undefined
            assertParamExists('createGroup', 'createGroup', createGroup)
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a group by identifier.  This operation also deletes all artifacts within the group, so should be used very carefully.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) * The group does not exist (HTTP error `404`) 
         * @summary Delete a group by the specified ID.
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupById: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteGroupById', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a group using the specified id.  This operation can fail for the following reasons:  * No group exists with the specified ID (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary Get a group by the specified ID.
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupById: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getGroupById', 'groupId', groupId)
            const localVarPath = `/groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all groups.  This list is paged.
         * @summary List groups
         * @param {number} [limit] The number of groups to return.  Defaults to 20.
         * @param {number} [offset] The number of groups to skip before starting the result set.  Defaults to 0.
         * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
         * @param {GroupSortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroups: async (limit?: number, offset?: number, order?: SortOrder, orderby?: GroupSortBy, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of all groups that match the provided filter criteria.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary Search for groups
         * @param {number} [offset] The number of artifacts to skip before starting to collect the result set.  Defaults to 0.
         * @param {number} [limit] The number of artifacts to return.  Defaults to 20.
         * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
         * @param {GroupSortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
         * @param {Array<string>} [labels] Filter by one or more name/value label.  Separate each name/value pair using a colon.  For example &#x60;labels&#x3D;foo:bar&#x60; will return only artifacts with a label named &#x60;foo&#x60; and value &#x60;bar&#x60;.
         * @param {string} [description] Filter by description.
         * @param {string} [groupId] Filter by group name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGroups: async (offset?: number, limit?: number, order?: SortOrder, orderby?: GroupSortBy, labels?: Array<string>, description?: string, groupId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }

            if (labels) {
                localVarQueryParameter['labels'] = labels;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['groupId'] = groupId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the metadata of a group using the specified id.  This operation can fail for the following reasons:  * No group exists with the specified ID (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary Update group metadata
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {EditableGroupMetaData} editableGroupMetaData The new group metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupById: async (groupId: string, editableGroupMetaData: EditableGroupMetaData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateGroupById', 'groupId', groupId)
            // verify required parameter 'editableGroupMetaData' is not null or undefined
            assertParamExists('updateGroupById', 'editableGroupMetaData', editableGroupMetaData)
            const localVarPath = `/groups/{groupId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editableGroupMetaData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new group.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) * The group already exist (HTTP error `409`) 
         * @summary Create a new group
         * @param {CreateGroup} createGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createGroup(createGroup: CreateGroup, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupMetaData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createGroup(createGroup, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.createGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a group by identifier.  This operation also deletes all artifacts within the group, so should be used very carefully.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) * The group does not exist (HTTP error `404`) 
         * @summary Delete a group by the specified ID.
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteGroupById(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteGroupById(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.deleteGroupById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a group using the specified id.  This operation can fail for the following reasons:  * No group exists with the specified ID (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary Get a group by the specified ID.
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGroupById(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupMetaData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGroupById(groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.getGroupById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all groups.  This list is paged.
         * @summary List groups
         * @param {number} [limit] The number of groups to return.  Defaults to 20.
         * @param {number} [offset] The number of groups to skip before starting the result set.  Defaults to 0.
         * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
         * @param {GroupSortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGroups(limit?: number, offset?: number, order?: SortOrder, orderby?: GroupSortBy, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupSearchResults>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGroups(limit, offset, order, orderby, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.listGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of all groups that match the provided filter criteria.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary Search for groups
         * @param {number} [offset] The number of artifacts to skip before starting to collect the result set.  Defaults to 0.
         * @param {number} [limit] The number of artifacts to return.  Defaults to 20.
         * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
         * @param {GroupSortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
         * @param {Array<string>} [labels] Filter by one or more name/value label.  Separate each name/value pair using a colon.  For example &#x60;labels&#x3D;foo:bar&#x60; will return only artifacts with a label named &#x60;foo&#x60; and value &#x60;bar&#x60;.
         * @param {string} [description] Filter by description.
         * @param {string} [groupId] Filter by group name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchGroups(offset?: number, limit?: number, order?: SortOrder, orderby?: GroupSortBy, labels?: Array<string>, description?: string, groupId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupSearchResults>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchGroups(offset, limit, order, orderby, labels, description, groupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.searchGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the metadata of a group using the specified id.  This operation can fail for the following reasons:  * No group exists with the specified ID (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary Update group metadata
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {EditableGroupMetaData} editableGroupMetaData The new group metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateGroupById(groupId: string, editableGroupMetaData: EditableGroupMetaData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateGroupById(groupId, editableGroupMetaData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['GroupsApi.updateGroupById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsApiFp(configuration)
    return {
        /**
         * Creates a new group.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) * The group already exist (HTTP error `409`) 
         * @summary Create a new group
         * @param {CreateGroup} createGroup 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createGroup(createGroup: CreateGroup, options?: any): AxiosPromise<GroupMetaData> {
            return localVarFp.createGroup(createGroup, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a group by identifier.  This operation also deletes all artifacts within the group, so should be used very carefully.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) * The group does not exist (HTTP error `404`) 
         * @summary Delete a group by the specified ID.
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteGroupById(groupId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteGroupById(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a group using the specified id.  This operation can fail for the following reasons:  * No group exists with the specified ID (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary Get a group by the specified ID.
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGroupById(groupId: string, options?: any): AxiosPromise<GroupMetaData> {
            return localVarFp.getGroupById(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all groups.  This list is paged.
         * @summary List groups
         * @param {number} [limit] The number of groups to return.  Defaults to 20.
         * @param {number} [offset] The number of groups to skip before starting the result set.  Defaults to 0.
         * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
         * @param {GroupSortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroups(limit?: number, offset?: number, order?: SortOrder, orderby?: GroupSortBy, options?: any): AxiosPromise<GroupSearchResults> {
            return localVarFp.listGroups(limit, offset, order, orderby, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of all groups that match the provided filter criteria.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary Search for groups
         * @param {number} [offset] The number of artifacts to skip before starting to collect the result set.  Defaults to 0.
         * @param {number} [limit] The number of artifacts to return.  Defaults to 20.
         * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
         * @param {GroupSortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
         * @param {Array<string>} [labels] Filter by one or more name/value label.  Separate each name/value pair using a colon.  For example &#x60;labels&#x3D;foo:bar&#x60; will return only artifacts with a label named &#x60;foo&#x60; and value &#x60;bar&#x60;.
         * @param {string} [description] Filter by description.
         * @param {string} [groupId] Filter by group name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchGroups(offset?: number, limit?: number, order?: SortOrder, orderby?: GroupSortBy, labels?: Array<string>, description?: string, groupId?: string, options?: any): AxiosPromise<GroupSearchResults> {
            return localVarFp.searchGroups(offset, limit, order, orderby, labels, description, groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the metadata of a group using the specified id.  This operation can fail for the following reasons:  * No group exists with the specified ID (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary Update group metadata
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {EditableGroupMetaData} editableGroupMetaData The new group metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateGroupById(groupId: string, editableGroupMetaData: EditableGroupMetaData, options?: any): AxiosPromise<void> {
            return localVarFp.updateGroupById(groupId, editableGroupMetaData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * Creates a new group.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) * The group already exist (HTTP error `409`) 
     * @summary Create a new group
     * @param {CreateGroup} createGroup 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public createGroup(createGroup: CreateGroup, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).createGroup(createGroup, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a group by identifier.  This operation also deletes all artifacts within the group, so should be used very carefully.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) * The group does not exist (HTTP error `404`) 
     * @summary Delete a group by the specified ID.
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public deleteGroupById(groupId: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).deleteGroupById(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a group using the specified id.  This operation can fail for the following reasons:  * No group exists with the specified ID (HTTP error `404`) * A server error occurred (HTTP error `500`)
     * @summary Get a group by the specified ID.
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public getGroupById(groupId: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).getGroupById(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all groups.  This list is paged.
     * @summary List groups
     * @param {number} [limit] The number of groups to return.  Defaults to 20.
     * @param {number} [offset] The number of groups to skip before starting the result set.  Defaults to 0.
     * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
     * @param {GroupSortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public listGroups(limit?: number, offset?: number, order?: SortOrder, orderby?: GroupSortBy, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).listGroups(limit, offset, order, orderby, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of all groups that match the provided filter criteria.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
     * @summary Search for groups
     * @param {number} [offset] The number of artifacts to skip before starting to collect the result set.  Defaults to 0.
     * @param {number} [limit] The number of artifacts to return.  Defaults to 20.
     * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
     * @param {GroupSortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
     * @param {Array<string>} [labels] Filter by one or more name/value label.  Separate each name/value pair using a colon.  For example &#x60;labels&#x3D;foo:bar&#x60; will return only artifacts with a label named &#x60;foo&#x60; and value &#x60;bar&#x60;.
     * @param {string} [description] Filter by description.
     * @param {string} [groupId] Filter by group name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public searchGroups(offset?: number, limit?: number, order?: SortOrder, orderby?: GroupSortBy, labels?: Array<string>, description?: string, groupId?: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).searchGroups(offset, limit, order, orderby, labels, description, groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the metadata of a group using the specified id.  This operation can fail for the following reasons:  * No group exists with the specified ID (HTTP error `404`) * A server error occurred (HTTP error `500`)
     * @summary Update group metadata
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {EditableGroupMetaData} editableGroupMetaData The new group metadata.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public updateGroupById(groupId: string, editableGroupMetaData: EditableGroupMetaData, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).updateGroupById(groupId, editableGroupMetaData, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * KafkaSQLApi - axios parameter creator
 * @export
 */
export const KafkaSQLApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Triggers the creation of a snapshot of the internal database for compatible storages.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary Trigger storage snapshot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerSnapshot: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/snapshots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KafkaSQLApi - functional programming interface
 * @export
 */
export const KafkaSQLApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = KafkaSQLApiAxiosParamCreator(configuration)
    return {
        /**
         * Triggers the creation of a snapshot of the internal database for compatible storages.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary Trigger storage snapshot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerSnapshot(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SnapshotMetaData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.triggerSnapshot(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KafkaSQLApi.triggerSnapshot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * KafkaSQLApi - factory interface
 * @export
 */
export const KafkaSQLApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = KafkaSQLApiFp(configuration)
    return {
        /**
         * Triggers the creation of a snapshot of the internal database for compatible storages.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary Trigger storage snapshot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerSnapshot(options?: any): AxiosPromise<SnapshotMetaData> {
            return localVarFp.triggerSnapshot(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KafkaSQLApi - object-oriented interface
 * @export
 * @class KafkaSQLApi
 * @extends {BaseAPI}
 */
export class KafkaSQLApi extends BaseAPI {
    /**
     * Triggers the creation of a snapshot of the internal database for compatible storages.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
     * @summary Trigger storage snapshot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KafkaSQLApi
     */
    public triggerSnapshot(options?: RawAxiosRequestConfig) {
        return KafkaSQLApiFp(this.configuration).triggerSnapshot(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MetadataApi - axios parameter creator
 * @export
 */
export const MetadataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets the metadata for an artifact in the registry, based on the latest version. If the latest version of the artifact is marked as `DISABLED`, the next available non-disabled version will be used. The returned metadata includes both generated (read-only) and editable metadata (such as name and description).  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists  or all versions are `DISABLED` (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary Get artifact metadata
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactMetaData: async (groupId: string, artifactId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getArtifactMetaData', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('getArtifactMetaData', 'artifactId', artifactId)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the metadata for a single version of the artifact.  The version metadata is  a subset of the artifact metadata and only includes the metadata that is specific to the version (for example, this doesn\'t include `modifiedOn`).  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get artifact version metadata
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} versionExpression An expression resolvable to a specific version ID within the given group and artifact. The following rules apply:   - If the expression is in the form \&quot;branch&#x3D;{branchId}\&quot;, and artifact branch {branchId} exists: The expression is resolved to a version that the branch points to.  - Otherwise: The expression is resolved to a version with the same ID, which must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactVersionMetaData: async (groupId: string, artifactId: string, versionExpression: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getArtifactVersionMetaData', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('getArtifactVersionMetaData', 'artifactId', artifactId)
            // verify required parameter 'versionExpression' is not null or undefined
            assertParamExists('getArtifactVersionMetaData', 'versionExpression', versionExpression)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/versions/{versionExpression}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"versionExpression"}}`, encodeURIComponent(String(versionExpression)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the editable parts of the artifact\'s metadata.  Not all metadata fields can be updated.  Note that only the properties included will be updated.  You can update only the name by including only the `name` property in the payload of the request. Properties that are allowed but not present will result in the artifact\'s metadata not being changed.  This operation can fail for the following reasons:  * No artifact with the `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary Update artifact metadata
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {EditableArtifactMetaData} editableArtifactMetaData Updated artifact metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtifactMetaData: async (groupId: string, artifactId: string, editableArtifactMetaData: EditableArtifactMetaData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateArtifactMetaData', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('updateArtifactMetaData', 'artifactId', artifactId)
            // verify required parameter 'editableArtifactMetaData' is not null or undefined
            assertParamExists('updateArtifactMetaData', 'editableArtifactMetaData', editableArtifactMetaData)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editableArtifactMetaData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the user-editable portion of the artifact version\'s metadata.  Only some of  the metadata fields are editable by the user.  For example, `description` is editable,  but `createdOn` is not.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Update artifact version metadata
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} versionExpression An expression resolvable to a specific version ID within the given group and artifact. The following rules apply:   - If the expression is in the form \&quot;branch&#x3D;{branchId}\&quot;, and artifact branch {branchId} exists: The expression is resolved to a version that the branch points to.  - Otherwise: The expression is resolved to a version with the same ID, which must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {EditableVersionMetaData} editableVersionMetaData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtifactVersionMetaData: async (groupId: string, artifactId: string, versionExpression: string, editableVersionMetaData: EditableVersionMetaData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateArtifactVersionMetaData', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('updateArtifactVersionMetaData', 'artifactId', artifactId)
            // verify required parameter 'versionExpression' is not null or undefined
            assertParamExists('updateArtifactVersionMetaData', 'versionExpression', versionExpression)
            // verify required parameter 'editableVersionMetaData' is not null or undefined
            assertParamExists('updateArtifactVersionMetaData', 'editableVersionMetaData', editableVersionMetaData)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/versions/{versionExpression}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"versionExpression"}}`, encodeURIComponent(String(versionExpression)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(editableVersionMetaData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetadataApi - functional programming interface
 * @export
 */
export const MetadataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetadataApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets the metadata for an artifact in the registry, based on the latest version. If the latest version of the artifact is marked as `DISABLED`, the next available non-disabled version will be used. The returned metadata includes both generated (read-only) and editable metadata (such as name and description).  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists  or all versions are `DISABLED` (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary Get artifact metadata
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtifactMetaData(groupId: string, artifactId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArtifactMetaData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArtifactMetaData(groupId, artifactId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetadataApi.getArtifactMetaData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the metadata for a single version of the artifact.  The version metadata is  a subset of the artifact metadata and only includes the metadata that is specific to the version (for example, this doesn\'t include `modifiedOn`).  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get artifact version metadata
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} versionExpression An expression resolvable to a specific version ID within the given group and artifact. The following rules apply:   - If the expression is in the form \&quot;branch&#x3D;{branchId}\&quot;, and artifact branch {branchId} exists: The expression is resolved to a version that the branch points to.  - Otherwise: The expression is resolved to a version with the same ID, which must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtifactVersionMetaData(groupId: string, artifactId: string, versionExpression: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionMetaData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArtifactVersionMetaData(groupId, artifactId, versionExpression, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetadataApi.getArtifactVersionMetaData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the editable parts of the artifact\'s metadata.  Not all metadata fields can be updated.  Note that only the properties included will be updated.  You can update only the name by including only the `name` property in the payload of the request. Properties that are allowed but not present will result in the artifact\'s metadata not being changed.  This operation can fail for the following reasons:  * No artifact with the `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary Update artifact metadata
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {EditableArtifactMetaData} editableArtifactMetaData Updated artifact metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateArtifactMetaData(groupId: string, artifactId: string, editableArtifactMetaData: EditableArtifactMetaData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateArtifactMetaData(groupId, artifactId, editableArtifactMetaData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetadataApi.updateArtifactMetaData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the user-editable portion of the artifact version\'s metadata.  Only some of  the metadata fields are editable by the user.  For example, `description` is editable,  but `createdOn` is not.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Update artifact version metadata
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} versionExpression An expression resolvable to a specific version ID within the given group and artifact. The following rules apply:   - If the expression is in the form \&quot;branch&#x3D;{branchId}\&quot;, and artifact branch {branchId} exists: The expression is resolved to a version that the branch points to.  - Otherwise: The expression is resolved to a version with the same ID, which must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {EditableVersionMetaData} editableVersionMetaData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateArtifactVersionMetaData(groupId: string, artifactId: string, versionExpression: string, editableVersionMetaData: EditableVersionMetaData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateArtifactVersionMetaData(groupId, artifactId, versionExpression, editableVersionMetaData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MetadataApi.updateArtifactVersionMetaData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MetadataApi - factory interface
 * @export
 */
export const MetadataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetadataApiFp(configuration)
    return {
        /**
         * Gets the metadata for an artifact in the registry, based on the latest version. If the latest version of the artifact is marked as `DISABLED`, the next available non-disabled version will be used. The returned metadata includes both generated (read-only) and editable metadata (such as name and description).  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists  or all versions are `DISABLED` (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary Get artifact metadata
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactMetaData(groupId: string, artifactId: string, options?: any): AxiosPromise<ArtifactMetaData> {
            return localVarFp.getArtifactMetaData(groupId, artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the metadata for a single version of the artifact.  The version metadata is  a subset of the artifact metadata and only includes the metadata that is specific to the version (for example, this doesn\'t include `modifiedOn`).  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get artifact version metadata
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} versionExpression An expression resolvable to a specific version ID within the given group and artifact. The following rules apply:   - If the expression is in the form \&quot;branch&#x3D;{branchId}\&quot;, and artifact branch {branchId} exists: The expression is resolved to a version that the branch points to.  - Otherwise: The expression is resolved to a version with the same ID, which must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactVersionMetaData(groupId: string, artifactId: string, versionExpression: string, options?: any): AxiosPromise<VersionMetaData> {
            return localVarFp.getArtifactVersionMetaData(groupId, artifactId, versionExpression, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the editable parts of the artifact\'s metadata.  Not all metadata fields can be updated.  Note that only the properties included will be updated.  You can update only the name by including only the `name` property in the payload of the request. Properties that are allowed but not present will result in the artifact\'s metadata not being changed.  This operation can fail for the following reasons:  * No artifact with the `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
         * @summary Update artifact metadata
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {EditableArtifactMetaData} editableArtifactMetaData Updated artifact metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtifactMetaData(groupId: string, artifactId: string, editableArtifactMetaData: EditableArtifactMetaData, options?: any): AxiosPromise<void> {
            return localVarFp.updateArtifactMetaData(groupId, artifactId, editableArtifactMetaData, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the user-editable portion of the artifact version\'s metadata.  Only some of  the metadata fields are editable by the user.  For example, `description` is editable,  but `createdOn` is not.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Update artifact version metadata
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} versionExpression An expression resolvable to a specific version ID within the given group and artifact. The following rules apply:   - If the expression is in the form \&quot;branch&#x3D;{branchId}\&quot;, and artifact branch {branchId} exists: The expression is resolved to a version that the branch points to.  - Otherwise: The expression is resolved to a version with the same ID, which must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {EditableVersionMetaData} editableVersionMetaData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtifactVersionMetaData(groupId: string, artifactId: string, versionExpression: string, editableVersionMetaData: EditableVersionMetaData, options?: any): AxiosPromise<void> {
            return localVarFp.updateArtifactVersionMetaData(groupId, artifactId, versionExpression, editableVersionMetaData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetadataApi - object-oriented interface
 * @export
 * @class MetadataApi
 * @extends {BaseAPI}
 */
export class MetadataApi extends BaseAPI {
    /**
     * Gets the metadata for an artifact in the registry, based on the latest version. If the latest version of the artifact is marked as `DISABLED`, the next available non-disabled version will be used. The returned metadata includes both generated (read-only) and editable metadata (such as name and description).  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists  or all versions are `DISABLED` (HTTP error `404`) * A server error occurred (HTTP error `500`)
     * @summary Get artifact metadata
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public getArtifactMetaData(groupId: string, artifactId: string, options?: RawAxiosRequestConfig) {
        return MetadataApiFp(this.configuration).getArtifactMetaData(groupId, artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the metadata for a single version of the artifact.  The version metadata is  a subset of the artifact metadata and only includes the metadata that is specific to the version (for example, this doesn\'t include `modifiedOn`).  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Get artifact version metadata
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} versionExpression An expression resolvable to a specific version ID within the given group and artifact. The following rules apply:   - If the expression is in the form \&quot;branch&#x3D;{branchId}\&quot;, and artifact branch {branchId} exists: The expression is resolved to a version that the branch points to.  - Otherwise: The expression is resolved to a version with the same ID, which must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public getArtifactVersionMetaData(groupId: string, artifactId: string, versionExpression: string, options?: RawAxiosRequestConfig) {
        return MetadataApiFp(this.configuration).getArtifactVersionMetaData(groupId, artifactId, versionExpression, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the editable parts of the artifact\'s metadata.  Not all metadata fields can be updated.  Note that only the properties included will be updated.  You can update only the name by including only the `name` property in the payload of the request. Properties that are allowed but not present will result in the artifact\'s metadata not being changed.  This operation can fail for the following reasons:  * No artifact with the `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`)
     * @summary Update artifact metadata
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {EditableArtifactMetaData} editableArtifactMetaData Updated artifact metadata.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public updateArtifactMetaData(groupId: string, artifactId: string, editableArtifactMetaData: EditableArtifactMetaData, options?: RawAxiosRequestConfig) {
        return MetadataApiFp(this.configuration).updateArtifactMetaData(groupId, artifactId, editableArtifactMetaData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the user-editable portion of the artifact version\'s metadata.  Only some of  the metadata fields are editable by the user.  For example, `description` is editable,  but `createdOn` is not.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Update artifact version metadata
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} versionExpression An expression resolvable to a specific version ID within the given group and artifact. The following rules apply:   - If the expression is in the form \&quot;branch&#x3D;{branchId}\&quot;, and artifact branch {branchId} exists: The expression is resolved to a version that the branch points to.  - Otherwise: The expression is resolved to a version with the same ID, which must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
     * @param {EditableVersionMetaData} editableVersionMetaData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataApi
     */
    public updateArtifactVersionMetaData(groupId: string, artifactId: string, versionExpression: string, editableVersionMetaData: EditableVersionMetaData, options?: RawAxiosRequestConfig) {
        return MetadataApiFp(this.configuration).updateArtifactVersionMetaData(groupId, artifactId, versionExpression, editableVersionMetaData, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SnapshotApi - axios parameter creator
 * @export
 */
export const SnapshotApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Triggers the creation of a snapshot of the internal database for compatible storages.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary Trigger storage snapshot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerSnapshot: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin/snapshots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SnapshotApi - functional programming interface
 * @export
 */
export const SnapshotApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SnapshotApiAxiosParamCreator(configuration)
    return {
        /**
         * Triggers the creation of a snapshot of the internal database for compatible storages.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary Trigger storage snapshot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerSnapshot(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SnapshotMetaData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.triggerSnapshot(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SnapshotApi.triggerSnapshot']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SnapshotApi - factory interface
 * @export
 */
export const SnapshotApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SnapshotApiFp(configuration)
    return {
        /**
         * Triggers the creation of a snapshot of the internal database for compatible storages.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary Trigger storage snapshot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerSnapshot(options?: any): AxiosPromise<SnapshotMetaData> {
            return localVarFp.triggerSnapshot(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SnapshotApi - object-oriented interface
 * @export
 * @class SnapshotApi
 * @extends {BaseAPI}
 */
export class SnapshotApi extends BaseAPI {
    /**
     * Triggers the creation of a snapshot of the internal database for compatible storages.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
     * @summary Trigger storage snapshot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SnapshotApi
     */
    public triggerSnapshot(options?: RawAxiosRequestConfig) {
        return SnapshotApiFp(this.configuration).triggerSnapshot(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SystemApi - axios parameter creator
 * @export
 */
export const SystemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This operation retrieves the list of limitations on used resources, that are applied on the current instance of Registry.
         * @summary Get resource limits information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceLimits: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/limits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This operation retrieves information about the running registry system, such as the version of the software and when it was built.
         * @summary Get system information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the UI configuration properties for this server.  The registry UI can be connected to a backend using just a URL.  The rest of the UI configuration can then be fetched from the backend using this operation.  This allows UI and backend to both be configured in the same place.  This operation may fail for one of the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary Get UI config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUIConfig: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/system/uiConfig`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemApi - functional programming interface
 * @export
 */
export const SystemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemApiAxiosParamCreator(configuration)
    return {
        /**
         * This operation retrieves the list of limitations on used resources, that are applied on the current instance of Registry.
         * @summary Get resource limits information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getResourceLimits(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Limits>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getResourceLimits(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.getResourceLimits']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This operation retrieves information about the running registry system, such as the version of the software and when it was built.
         * @summary Get system information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.getSystemInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the UI configuration properties for this server.  The registry UI can be connected to a backend using just a URL.  The rest of the UI configuration can then be fetched from the backend using this operation.  This allows UI and backend to both be configured in the same place.  This operation may fail for one of the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary Get UI config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUIConfig(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInterfaceConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUIConfig(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemApi.getUIConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SystemApi - factory interface
 * @export
 */
export const SystemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemApiFp(configuration)
    return {
        /**
         * This operation retrieves the list of limitations on used resources, that are applied on the current instance of Registry.
         * @summary Get resource limits information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResourceLimits(options?: any): AxiosPromise<Limits> {
            return localVarFp.getResourceLimits(options).then((request) => request(axios, basePath));
        },
        /**
         * This operation retrieves information about the running registry system, such as the version of the software and when it was built.
         * @summary Get system information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemInfo(options?: any): AxiosPromise<SystemInfo> {
            return localVarFp.getSystemInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the UI configuration properties for this server.  The registry UI can be connected to a backend using just a URL.  The rest of the UI configuration can then be fetched from the backend using this operation.  This allows UI and backend to both be configured in the same place.  This operation may fail for one of the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary Get UI config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUIConfig(options?: any): AxiosPromise<UserInterfaceConfig> {
            return localVarFp.getUIConfig(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
    /**
     * This operation retrieves the list of limitations on used resources, that are applied on the current instance of Registry.
     * @summary Get resource limits information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getResourceLimits(options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).getResourceLimits(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This operation retrieves information about the running registry system, such as the version of the software and when it was built.
     * @summary Get system information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getSystemInfo(options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).getSystemInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the UI configuration properties for this server.  The registry UI can be connected to a backend using just a URL.  The rest of the UI configuration can then be fetched from the backend using this operation.  This allows UI and backend to both be configured in the same place.  This operation may fail for one of the following reasons:  * A server error occurred (HTTP error `500`) 
     * @summary Get UI config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public getUIConfig(options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).getUIConfig(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns information about the currently authenticated user.
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns information about the currently authenticated user.
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUserInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUserInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UsersApi.getCurrentUserInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Returns information about the currently authenticated user.
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserInfo(options?: any): AxiosPromise<UserInfo> {
            return localVarFp.getCurrentUserInfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Returns information about the currently authenticated user.
     * @summary Get current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getCurrentUserInfo(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).getCurrentUserInfo(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VersionsApi - axios parameter creator
 * @export
 */
export const VersionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds a new comment to the artifact version.  Both the `artifactId` and the unique `version` number must be provided.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Add new comment
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} versionExpression An expression resolvable to a specific version ID within the given group and artifact. The following rules apply:   - If the expression is in the form \&quot;branch&#x3D;{branchId}\&quot;, and artifact branch {branchId} exists: The expression is resolved to a version that the branch points to.  - Otherwise: The expression is resolved to a version with the same ID, which must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {NewComment} newComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addArtifactVersionComment: async (groupId: string, artifactId: string, versionExpression: string, newComment: NewComment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('addArtifactVersionComment', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('addArtifactVersionComment', 'artifactId', artifactId)
            // verify required parameter 'versionExpression' is not null or undefined
            assertParamExists('addArtifactVersionComment', 'versionExpression', versionExpression)
            // verify required parameter 'newComment' is not null or undefined
            assertParamExists('addArtifactVersionComment', 'newComment', newComment)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/versions/{versionExpression}/comments`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"versionExpression"}}`, encodeURIComponent(String(versionExpression)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newComment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new version of the artifact by uploading new content.  The configured rules for the artifact are applied, and if they all pass, the new content is added as the most recent  version of the artifact.  If any of the rules fail, an error is returned.  The body of the request can be the raw content of the new artifact version, or the raw content  and a set of references pointing to other artifacts, and the type of that content should match the artifact\'s type (for example if the artifact type is `AVRO` then the content of the request should be an Apache Avro document).  This operation can fail for the following reasons:  * Provided content (request body) was empty (HTTP error `400`) * An invalid version number was provided (HTTP error `400`) * No artifact with this `artifactId` exists (HTTP error `404`) * The new content violates one of the rules configured for the artifact (HTTP error `409`) * A server error occurred (HTTP error `500`) 
         * @summary Create artifact version
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {CreateVersion} createVersion The version to be created.
         * @param {boolean} [dryRun] When set to &#x60;true&#x60;, the operation will not result in any changes. Instead, it will return a result based on whether the operation **would have succeeded**.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifactVersion: async (groupId: string, artifactId: string, createVersion: CreateVersion, dryRun?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('createArtifactVersion', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('createArtifactVersion', 'artifactId', artifactId)
            // verify required parameter 'createVersion' is not null or undefined
            assertParamExists('createArtifactVersion', 'createVersion', createVersion)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/versions`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (dryRun !== undefined) {
                localVarQueryParameter['dryRun'] = dryRun;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createVersion, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a single version of the artifact. Parameters `groupId`, `artifactId` and the unique `version` are needed. If this is the only version of the artifact, this operation is the same as  deleting the entire artifact.  This feature is disabled by default and it\'s discouraged for normal usage. To enable it, set the `registry.rest.artifact.deletion.enabled` property to true. This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`)  * Feature is disabled (HTTP error `405`)  * A server error occurred (HTTP error `500`) 
         * @summary Delete artifact version
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} versionExpression An expression resolvable to a specific version ID within the given group and artifact. The following rules apply:   - If the expression is in the form \&quot;branch&#x3D;{branchId}\&quot;, and artifact branch {branchId} exists: The expression is resolved to a version that the branch points to.  - Otherwise: The expression is resolved to a version with the same ID, which must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifactVersion: async (groupId: string, artifactId: string, versionExpression: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteArtifactVersion', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('deleteArtifactVersion', 'artifactId', artifactId)
            // verify required parameter 'versionExpression' is not null or undefined
            assertParamExists('deleteArtifactVersion', 'versionExpression', versionExpression)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/versions/{versionExpression}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"versionExpression"}}`, encodeURIComponent(String(versionExpression)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a single comment in an artifact version.  Only the owner of the comment can delete it.  The `artifactId`, unique `version` number, and `commentId`  must be provided.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * No comment with this `commentId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Delete a single comment
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} versionExpression An expression resolvable to a specific version ID within the given group and artifact. The following rules apply:   - If the expression is in the form \&quot;branch&#x3D;{branchId}\&quot;, and artifact branch {branchId} exists: The expression is resolved to a version that the branch points to.  - Otherwise: The expression is resolved to a version with the same ID, which must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {string} commentId The unique identifier of a single comment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifactVersionComment: async (groupId: string, artifactId: string, versionExpression: string, commentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('deleteArtifactVersionComment', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('deleteArtifactVersionComment', 'artifactId', artifactId)
            // verify required parameter 'versionExpression' is not null or undefined
            assertParamExists('deleteArtifactVersionComment', 'versionExpression', versionExpression)
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('deleteArtifactVersionComment', 'commentId', commentId)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/versions/{versionExpression}/comments/{commentId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"versionExpression"}}`, encodeURIComponent(String(versionExpression)))
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all comments for a version of an artifact.  Both the `artifactId` and the unique `version` number must be provided.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get artifact version comments
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} versionExpression An expression resolvable to a specific version ID within the given group and artifact. The following rules apply:   - If the expression is in the form \&quot;branch&#x3D;{branchId}\&quot;, and artifact branch {branchId} exists: The expression is resolved to a version that the branch points to.  - Otherwise: The expression is resolved to a version with the same ID, which must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactVersionComments: async (groupId: string, artifactId: string, versionExpression: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getArtifactVersionComments', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('getArtifactVersionComments', 'artifactId', artifactId)
            // verify required parameter 'versionExpression' is not null or undefined
            assertParamExists('getArtifactVersionComments', 'versionExpression', versionExpression)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/versions/{versionExpression}/comments`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"versionExpression"}}`, encodeURIComponent(String(versionExpression)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single version of the artifact content.  Both the `artifactId` and the unique `version` number must be provided.  The `Content-Type` of the response depends  on the artifact type.  In most cases, this is `application/json`, but for some types  it may be different (for example, `PROTOBUF`).  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get artifact version
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} versionExpression An expression resolvable to a specific version ID within the given group and artifact. The following rules apply:   - If the expression is in the form \&quot;branch&#x3D;{branchId}\&quot;, and artifact branch {branchId} exists: The expression is resolved to a version that the branch points to.  - Otherwise: The expression is resolved to a version with the same ID, which must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {HandleReferencesType} [references] Allows the user to specify how references in the content should be treated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactVersionContent: async (groupId: string, artifactId: string, versionExpression: string, references?: HandleReferencesType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getArtifactVersionContent', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('getArtifactVersionContent', 'artifactId', artifactId)
            // verify required parameter 'versionExpression' is not null or undefined
            assertParamExists('getArtifactVersionContent', 'versionExpression', versionExpression)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/versions/{versionExpression}/content`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"versionExpression"}}`, encodeURIComponent(String(versionExpression)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (references !== undefined) {
                localVarQueryParameter['references'] = references;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all references for a single version of an artifact.  Both the `artifactId` and the unique `version` number must be provided.  Using the `refType` query parameter, it is possible to retrieve an array of either the inbound or outbound references.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get artifact version references
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} versionExpression An expression resolvable to a specific version ID within the given group and artifact. The following rules apply:   - If the expression is in the form \&quot;branch&#x3D;{branchId}\&quot;, and artifact branch {branchId} exists: The expression is resolved to a version that the branch points to.  - Otherwise: The expression is resolved to a version with the same ID, which must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {ReferenceType} [refType] Determines the type of reference to return, either INBOUND or OUTBOUND.  Defaults to OUTBOUND.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactVersionReferences: async (groupId: string, artifactId: string, versionExpression: string, refType?: ReferenceType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('getArtifactVersionReferences', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('getArtifactVersionReferences', 'artifactId', artifactId)
            // verify required parameter 'versionExpression' is not null or undefined
            assertParamExists('getArtifactVersionReferences', 'versionExpression', versionExpression)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/versions/{versionExpression}/references`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"versionExpression"}}`, encodeURIComponent(String(versionExpression)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (refType !== undefined) {
                localVarQueryParameter['refType'] = refType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all versions of the artifact.  The result set is paged.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary List artifact versions
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {number} [offset] The number of versions to skip before starting to collect the result set.  Defaults to 0.
         * @param {number} [limit] The number of versions to return.  Defaults to 20.
         * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
         * @param {VersionSortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;version&#x60; * &#x60;createdOn&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifactVersions: async (groupId: string, artifactId: string, offset?: number, limit?: number, order?: SortOrder, orderby?: VersionSortBy, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('listArtifactVersions', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('listArtifactVersions', 'artifactId', artifactId)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/versions`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of all versions that match the provided filter criteria.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary Search for versions
         * @param {string} [version] Filter by version number.
         * @param {number} [offset] The number of versions to skip before starting to collect the result set.  Defaults to 0.
         * @param {number} [limit] The number of versions to return.  Defaults to 20.
         * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
         * @param {VersionSortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
         * @param {Array<string>} [labels] Filter by one or more name/value label.  Separate each name/value pair using a colon.  For example &#x60;labels&#x3D;foo:bar&#x60; will return only artifacts with a label named &#x60;foo&#x60; and value &#x60;bar&#x60;.
         * @param {string} [description] Filter by description.
         * @param {string} [groupId] Filter by artifact group.
         * @param {number} [globalId] Filter by globalId.
         * @param {number} [contentId] Filter by contentId.
         * @param {string} [artifactId] Filter by artifactId.
         * @param {string} [name] Filter by name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchVersions: async (version?: string, offset?: number, limit?: number, order?: SortOrder, orderby?: VersionSortBy, labels?: Array<string>, description?: string, groupId?: string, globalId?: number, contentId?: number, artifactId?: string, name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }

            if (labels) {
                localVarQueryParameter['labels'] = labels;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['groupId'] = groupId;
            }

            if (globalId !== undefined) {
                localVarQueryParameter['globalId'] = globalId;
            }

            if (contentId !== undefined) {
                localVarQueryParameter['contentId'] = contentId;
            }

            if (artifactId !== undefined) {
                localVarQueryParameter['artifactId'] = artifactId;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of all versions that match the posted content.  This operation can fail for the following reasons:  * Provided content (request body) was empty (HTTP error `400`) * A server error occurred (HTTP error `500`) 
         * @summary Search for versions by content
         * @param {File} body The content to search for.
         * @param {boolean} [canonical] Parameter that can be set to &#x60;true&#x60; to indicate that the server should \&quot;canonicalize\&quot; the content when searching for matching artifacts.  Canonicalization is unique to each artifact type, but typically involves removing any extra whitespace and formatting the content in a consistent manner.  Must be used along with the &#x60;artifactType&#x60; query parameter.
         * @param {string} [artifactType] Indicates the type of artifact represented by the content being used for the search.  This is only needed when using the &#x60;canonical&#x60; query parameter, so that the server knows how to canonicalize the content prior to searching for matching versions.
         * @param {number} [offset] The number of versions to skip before starting to collect the result set.  Defaults to 0.
         * @param {number} [limit] The number of versions to return.  Defaults to 20.
         * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
         * @param {VersionSortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
         * @param {string} [groupId] Filter by group Id.
         * @param {string} [artifactId] Filter by artifact Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchVersionsByContent: async (body: File, canonical?: boolean, artifactType?: string, offset?: number, limit?: number, order?: SortOrder, orderby?: VersionSortBy, groupId?: string, artifactId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('searchVersionsByContent', 'body', body)
            const localVarPath = `/search/versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (canonical !== undefined) {
                localVarQueryParameter['canonical'] = canonical;
            }

            if (artifactType !== undefined) {
                localVarQueryParameter['artifactType'] = artifactType;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (orderby !== undefined) {
                localVarQueryParameter['orderby'] = orderby;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['groupId'] = groupId;
            }

            if (artifactId !== undefined) {
                localVarQueryParameter['artifactId'] = artifactId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the value of a single comment in an artifact version.  Only the owner of the comment can modify it.  The `artifactId`, unique `version` number, and `commentId`  must be provided.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * No comment with this `commentId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Update a comment
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} versionExpression An expression resolvable to a specific version ID within the given group and artifact. The following rules apply:   - If the expression is in the form \&quot;branch&#x3D;{branchId}\&quot;, and artifact branch {branchId} exists: The expression is resolved to a version that the branch points to.  - Otherwise: The expression is resolved to a version with the same ID, which must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {string} commentId The unique identifier of a single comment.
         * @param {NewComment} newComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtifactVersionComment: async (groupId: string, artifactId: string, versionExpression: string, commentId: string, newComment: NewComment, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('updateArtifactVersionComment', 'groupId', groupId)
            // verify required parameter 'artifactId' is not null or undefined
            assertParamExists('updateArtifactVersionComment', 'artifactId', artifactId)
            // verify required parameter 'versionExpression' is not null or undefined
            assertParamExists('updateArtifactVersionComment', 'versionExpression', versionExpression)
            // verify required parameter 'commentId' is not null or undefined
            assertParamExists('updateArtifactVersionComment', 'commentId', commentId)
            // verify required parameter 'newComment' is not null or undefined
            assertParamExists('updateArtifactVersionComment', 'newComment', newComment)
            const localVarPath = `/groups/{groupId}/artifacts/{artifactId}/versions/{versionExpression}/comments/{commentId}`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"artifactId"}}`, encodeURIComponent(String(artifactId)))
                .replace(`{${"versionExpression"}}`, encodeURIComponent(String(versionExpression)))
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newComment, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VersionsApi - functional programming interface
 * @export
 */
export const VersionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VersionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Adds a new comment to the artifact version.  Both the `artifactId` and the unique `version` number must be provided.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Add new comment
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} versionExpression An expression resolvable to a specific version ID within the given group and artifact. The following rules apply:   - If the expression is in the form \&quot;branch&#x3D;{branchId}\&quot;, and artifact branch {branchId} exists: The expression is resolved to a version that the branch points to.  - Otherwise: The expression is resolved to a version with the same ID, which must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {NewComment} newComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addArtifactVersionComment(groupId: string, artifactId: string, versionExpression: string, newComment: NewComment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addArtifactVersionComment(groupId, artifactId, versionExpression, newComment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VersionsApi.addArtifactVersionComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Creates a new version of the artifact by uploading new content.  The configured rules for the artifact are applied, and if they all pass, the new content is added as the most recent  version of the artifact.  If any of the rules fail, an error is returned.  The body of the request can be the raw content of the new artifact version, or the raw content  and a set of references pointing to other artifacts, and the type of that content should match the artifact\'s type (for example if the artifact type is `AVRO` then the content of the request should be an Apache Avro document).  This operation can fail for the following reasons:  * Provided content (request body) was empty (HTTP error `400`) * An invalid version number was provided (HTTP error `400`) * No artifact with this `artifactId` exists (HTTP error `404`) * The new content violates one of the rules configured for the artifact (HTTP error `409`) * A server error occurred (HTTP error `500`) 
         * @summary Create artifact version
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {CreateVersion} createVersion The version to be created.
         * @param {boolean} [dryRun] When set to &#x60;true&#x60;, the operation will not result in any changes. Instead, it will return a result based on whether the operation **would have succeeded**.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createArtifactVersion(groupId: string, artifactId: string, createVersion: CreateVersion, dryRun?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionMetaData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createArtifactVersion(groupId, artifactId, createVersion, dryRun, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VersionsApi.createArtifactVersion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a single version of the artifact. Parameters `groupId`, `artifactId` and the unique `version` are needed. If this is the only version of the artifact, this operation is the same as  deleting the entire artifact.  This feature is disabled by default and it\'s discouraged for normal usage. To enable it, set the `registry.rest.artifact.deletion.enabled` property to true. This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`)  * Feature is disabled (HTTP error `405`)  * A server error occurred (HTTP error `500`) 
         * @summary Delete artifact version
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} versionExpression An expression resolvable to a specific version ID within the given group and artifact. The following rules apply:   - If the expression is in the form \&quot;branch&#x3D;{branchId}\&quot;, and artifact branch {branchId} exists: The expression is resolved to a version that the branch points to.  - Otherwise: The expression is resolved to a version with the same ID, which must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteArtifactVersion(groupId: string, artifactId: string, versionExpression: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteArtifactVersion(groupId, artifactId, versionExpression, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VersionsApi.deleteArtifactVersion']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a single comment in an artifact version.  Only the owner of the comment can delete it.  The `artifactId`, unique `version` number, and `commentId`  must be provided.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * No comment with this `commentId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Delete a single comment
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} versionExpression An expression resolvable to a specific version ID within the given group and artifact. The following rules apply:   - If the expression is in the form \&quot;branch&#x3D;{branchId}\&quot;, and artifact branch {branchId} exists: The expression is resolved to a version that the branch points to.  - Otherwise: The expression is resolved to a version with the same ID, which must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {string} commentId The unique identifier of a single comment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteArtifactVersionComment(groupId: string, artifactId: string, versionExpression: string, commentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteArtifactVersionComment(groupId, artifactId, versionExpression, commentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VersionsApi.deleteArtifactVersionComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all comments for a version of an artifact.  Both the `artifactId` and the unique `version` number must be provided.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get artifact version comments
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} versionExpression An expression resolvable to a specific version ID within the given group and artifact. The following rules apply:   - If the expression is in the form \&quot;branch&#x3D;{branchId}\&quot;, and artifact branch {branchId} exists: The expression is resolved to a version that the branch points to.  - Otherwise: The expression is resolved to a version with the same ID, which must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtifactVersionComments(groupId: string, artifactId: string, versionExpression: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Comment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArtifactVersionComments(groupId, artifactId, versionExpression, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VersionsApi.getArtifactVersionComments']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a single version of the artifact content.  Both the `artifactId` and the unique `version` number must be provided.  The `Content-Type` of the response depends  on the artifact type.  In most cases, this is `application/json`, but for some types  it may be different (for example, `PROTOBUF`).  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get artifact version
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} versionExpression An expression resolvable to a specific version ID within the given group and artifact. The following rules apply:   - If the expression is in the form \&quot;branch&#x3D;{branchId}\&quot;, and artifact branch {branchId} exists: The expression is resolved to a version that the branch points to.  - Otherwise: The expression is resolved to a version with the same ID, which must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {HandleReferencesType} [references] Allows the user to specify how references in the content should be treated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtifactVersionContent(groupId: string, artifactId: string, versionExpression: string, references?: HandleReferencesType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArtifactVersionContent(groupId, artifactId, versionExpression, references, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VersionsApi.getArtifactVersionContent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all references for a single version of an artifact.  Both the `artifactId` and the unique `version` number must be provided.  Using the `refType` query parameter, it is possible to retrieve an array of either the inbound or outbound references.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get artifact version references
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} versionExpression An expression resolvable to a specific version ID within the given group and artifact. The following rules apply:   - If the expression is in the form \&quot;branch&#x3D;{branchId}\&quot;, and artifact branch {branchId} exists: The expression is resolved to a version that the branch points to.  - Otherwise: The expression is resolved to a version with the same ID, which must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {ReferenceType} [refType] Determines the type of reference to return, either INBOUND or OUTBOUND.  Defaults to OUTBOUND.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtifactVersionReferences(groupId: string, artifactId: string, versionExpression: string, refType?: ReferenceType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtifactReference>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArtifactVersionReferences(groupId, artifactId, versionExpression, refType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VersionsApi.getArtifactVersionReferences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of all versions of the artifact.  The result set is paged.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary List artifact versions
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {number} [offset] The number of versions to skip before starting to collect the result set.  Defaults to 0.
         * @param {number} [limit] The number of versions to return.  Defaults to 20.
         * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
         * @param {VersionSortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;version&#x60; * &#x60;createdOn&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listArtifactVersions(groupId: string, artifactId: string, offset?: number, limit?: number, order?: SortOrder, orderby?: VersionSortBy, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionSearchResults>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listArtifactVersions(groupId, artifactId, offset, limit, order, orderby, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VersionsApi.listArtifactVersions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of all versions that match the provided filter criteria.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary Search for versions
         * @param {string} [version] Filter by version number.
         * @param {number} [offset] The number of versions to skip before starting to collect the result set.  Defaults to 0.
         * @param {number} [limit] The number of versions to return.  Defaults to 20.
         * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
         * @param {VersionSortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
         * @param {Array<string>} [labels] Filter by one or more name/value label.  Separate each name/value pair using a colon.  For example &#x60;labels&#x3D;foo:bar&#x60; will return only artifacts with a label named &#x60;foo&#x60; and value &#x60;bar&#x60;.
         * @param {string} [description] Filter by description.
         * @param {string} [groupId] Filter by artifact group.
         * @param {number} [globalId] Filter by globalId.
         * @param {number} [contentId] Filter by contentId.
         * @param {string} [artifactId] Filter by artifactId.
         * @param {string} [name] Filter by name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchVersions(version?: string, offset?: number, limit?: number, order?: SortOrder, orderby?: VersionSortBy, labels?: Array<string>, description?: string, groupId?: string, globalId?: number, contentId?: number, artifactId?: string, name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionSearchResults>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchVersions(version, offset, limit, order, orderby, labels, description, groupId, globalId, contentId, artifactId, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VersionsApi.searchVersions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of all versions that match the posted content.  This operation can fail for the following reasons:  * Provided content (request body) was empty (HTTP error `400`) * A server error occurred (HTTP error `500`) 
         * @summary Search for versions by content
         * @param {File} body The content to search for.
         * @param {boolean} [canonical] Parameter that can be set to &#x60;true&#x60; to indicate that the server should \&quot;canonicalize\&quot; the content when searching for matching artifacts.  Canonicalization is unique to each artifact type, but typically involves removing any extra whitespace and formatting the content in a consistent manner.  Must be used along with the &#x60;artifactType&#x60; query parameter.
         * @param {string} [artifactType] Indicates the type of artifact represented by the content being used for the search.  This is only needed when using the &#x60;canonical&#x60; query parameter, so that the server knows how to canonicalize the content prior to searching for matching versions.
         * @param {number} [offset] The number of versions to skip before starting to collect the result set.  Defaults to 0.
         * @param {number} [limit] The number of versions to return.  Defaults to 20.
         * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
         * @param {VersionSortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
         * @param {string} [groupId] Filter by group Id.
         * @param {string} [artifactId] Filter by artifact Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchVersionsByContent(body: File, canonical?: boolean, artifactType?: string, offset?: number, limit?: number, order?: SortOrder, orderby?: VersionSortBy, groupId?: string, artifactId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VersionSearchResults>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchVersionsByContent(body, canonical, artifactType, offset, limit, order, orderby, groupId, artifactId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VersionsApi.searchVersionsByContent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates the value of a single comment in an artifact version.  Only the owner of the comment can modify it.  The `artifactId`, unique `version` number, and `commentId`  must be provided.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * No comment with this `commentId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Update a comment
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} versionExpression An expression resolvable to a specific version ID within the given group and artifact. The following rules apply:   - If the expression is in the form \&quot;branch&#x3D;{branchId}\&quot;, and artifact branch {branchId} exists: The expression is resolved to a version that the branch points to.  - Otherwise: The expression is resolved to a version with the same ID, which must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {string} commentId The unique identifier of a single comment.
         * @param {NewComment} newComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateArtifactVersionComment(groupId: string, artifactId: string, versionExpression: string, commentId: string, newComment: NewComment, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateArtifactVersionComment(groupId, artifactId, versionExpression, commentId, newComment, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VersionsApi.updateArtifactVersionComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VersionsApi - factory interface
 * @export
 */
export const VersionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VersionsApiFp(configuration)
    return {
        /**
         * Adds a new comment to the artifact version.  Both the `artifactId` and the unique `version` number must be provided.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Add new comment
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} versionExpression An expression resolvable to a specific version ID within the given group and artifact. The following rules apply:   - If the expression is in the form \&quot;branch&#x3D;{branchId}\&quot;, and artifact branch {branchId} exists: The expression is resolved to a version that the branch points to.  - Otherwise: The expression is resolved to a version with the same ID, which must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {NewComment} newComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addArtifactVersionComment(groupId: string, artifactId: string, versionExpression: string, newComment: NewComment, options?: any): AxiosPromise<Comment> {
            return localVarFp.addArtifactVersionComment(groupId, artifactId, versionExpression, newComment, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new version of the artifact by uploading new content.  The configured rules for the artifact are applied, and if they all pass, the new content is added as the most recent  version of the artifact.  If any of the rules fail, an error is returned.  The body of the request can be the raw content of the new artifact version, or the raw content  and a set of references pointing to other artifacts, and the type of that content should match the artifact\'s type (for example if the artifact type is `AVRO` then the content of the request should be an Apache Avro document).  This operation can fail for the following reasons:  * Provided content (request body) was empty (HTTP error `400`) * An invalid version number was provided (HTTP error `400`) * No artifact with this `artifactId` exists (HTTP error `404`) * The new content violates one of the rules configured for the artifact (HTTP error `409`) * A server error occurred (HTTP error `500`) 
         * @summary Create artifact version
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {CreateVersion} createVersion The version to be created.
         * @param {boolean} [dryRun] When set to &#x60;true&#x60;, the operation will not result in any changes. Instead, it will return a result based on whether the operation **would have succeeded**.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createArtifactVersion(groupId: string, artifactId: string, createVersion: CreateVersion, dryRun?: boolean, options?: any): AxiosPromise<VersionMetaData> {
            return localVarFp.createArtifactVersion(groupId, artifactId, createVersion, dryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a single version of the artifact. Parameters `groupId`, `artifactId` and the unique `version` are needed. If this is the only version of the artifact, this operation is the same as  deleting the entire artifact.  This feature is disabled by default and it\'s discouraged for normal usage. To enable it, set the `registry.rest.artifact.deletion.enabled` property to true. This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`)  * Feature is disabled (HTTP error `405`)  * A server error occurred (HTTP error `500`) 
         * @summary Delete artifact version
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} versionExpression An expression resolvable to a specific version ID within the given group and artifact. The following rules apply:   - If the expression is in the form \&quot;branch&#x3D;{branchId}\&quot;, and artifact branch {branchId} exists: The expression is resolved to a version that the branch points to.  - Otherwise: The expression is resolved to a version with the same ID, which must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifactVersion(groupId: string, artifactId: string, versionExpression: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteArtifactVersion(groupId, artifactId, versionExpression, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a single comment in an artifact version.  Only the owner of the comment can delete it.  The `artifactId`, unique `version` number, and `commentId`  must be provided.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * No comment with this `commentId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Delete a single comment
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} versionExpression An expression resolvable to a specific version ID within the given group and artifact. The following rules apply:   - If the expression is in the form \&quot;branch&#x3D;{branchId}\&quot;, and artifact branch {branchId} exists: The expression is resolved to a version that the branch points to.  - Otherwise: The expression is resolved to a version with the same ID, which must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {string} commentId The unique identifier of a single comment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteArtifactVersionComment(groupId: string, artifactId: string, versionExpression: string, commentId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteArtifactVersionComment(groupId, artifactId, versionExpression, commentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all comments for a version of an artifact.  Both the `artifactId` and the unique `version` number must be provided.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get artifact version comments
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} versionExpression An expression resolvable to a specific version ID within the given group and artifact. The following rules apply:   - If the expression is in the form \&quot;branch&#x3D;{branchId}\&quot;, and artifact branch {branchId} exists: The expression is resolved to a version that the branch points to.  - Otherwise: The expression is resolved to a version with the same ID, which must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactVersionComments(groupId: string, artifactId: string, versionExpression: string, options?: any): AxiosPromise<Array<Comment>> {
            return localVarFp.getArtifactVersionComments(groupId, artifactId, versionExpression, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single version of the artifact content.  Both the `artifactId` and the unique `version` number must be provided.  The `Content-Type` of the response depends  on the artifact type.  In most cases, this is `application/json`, but for some types  it may be different (for example, `PROTOBUF`).  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get artifact version
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} versionExpression An expression resolvable to a specific version ID within the given group and artifact. The following rules apply:   - If the expression is in the form \&quot;branch&#x3D;{branchId}\&quot;, and artifact branch {branchId} exists: The expression is resolved to a version that the branch points to.  - Otherwise: The expression is resolved to a version with the same ID, which must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {HandleReferencesType} [references] Allows the user to specify how references in the content should be treated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactVersionContent(groupId: string, artifactId: string, versionExpression: string, references?: HandleReferencesType, options?: any): AxiosPromise<File> {
            return localVarFp.getArtifactVersionContent(groupId, artifactId, versionExpression, references, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all references for a single version of an artifact.  Both the `artifactId` and the unique `version` number must be provided.  Using the `refType` query parameter, it is possible to retrieve an array of either the inbound or outbound references.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Get artifact version references
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} versionExpression An expression resolvable to a specific version ID within the given group and artifact. The following rules apply:   - If the expression is in the form \&quot;branch&#x3D;{branchId}\&quot;, and artifact branch {branchId} exists: The expression is resolved to a version that the branch points to.  - Otherwise: The expression is resolved to a version with the same ID, which must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {ReferenceType} [refType] Determines the type of reference to return, either INBOUND or OUTBOUND.  Defaults to OUTBOUND.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtifactVersionReferences(groupId: string, artifactId: string, versionExpression: string, refType?: ReferenceType, options?: any): AxiosPromise<Array<ArtifactReference>> {
            return localVarFp.getArtifactVersionReferences(groupId, artifactId, versionExpression, refType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all versions of the artifact.  The result set is paged.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary List artifact versions
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {number} [offset] The number of versions to skip before starting to collect the result set.  Defaults to 0.
         * @param {number} [limit] The number of versions to return.  Defaults to 20.
         * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
         * @param {VersionSortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;version&#x60; * &#x60;createdOn&#x60; 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listArtifactVersions(groupId: string, artifactId: string, offset?: number, limit?: number, order?: SortOrder, orderby?: VersionSortBy, options?: any): AxiosPromise<VersionSearchResults> {
            return localVarFp.listArtifactVersions(groupId, artifactId, offset, limit, order, orderby, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of all versions that match the provided filter criteria.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
         * @summary Search for versions
         * @param {string} [version] Filter by version number.
         * @param {number} [offset] The number of versions to skip before starting to collect the result set.  Defaults to 0.
         * @param {number} [limit] The number of versions to return.  Defaults to 20.
         * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
         * @param {VersionSortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
         * @param {Array<string>} [labels] Filter by one or more name/value label.  Separate each name/value pair using a colon.  For example &#x60;labels&#x3D;foo:bar&#x60; will return only artifacts with a label named &#x60;foo&#x60; and value &#x60;bar&#x60;.
         * @param {string} [description] Filter by description.
         * @param {string} [groupId] Filter by artifact group.
         * @param {number} [globalId] Filter by globalId.
         * @param {number} [contentId] Filter by contentId.
         * @param {string} [artifactId] Filter by artifactId.
         * @param {string} [name] Filter by name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchVersions(version?: string, offset?: number, limit?: number, order?: SortOrder, orderby?: VersionSortBy, labels?: Array<string>, description?: string, groupId?: string, globalId?: number, contentId?: number, artifactId?: string, name?: string, options?: any): AxiosPromise<VersionSearchResults> {
            return localVarFp.searchVersions(version, offset, limit, order, orderby, labels, description, groupId, globalId, contentId, artifactId, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of all versions that match the posted content.  This operation can fail for the following reasons:  * Provided content (request body) was empty (HTTP error `400`) * A server error occurred (HTTP error `500`) 
         * @summary Search for versions by content
         * @param {File} body The content to search for.
         * @param {boolean} [canonical] Parameter that can be set to &#x60;true&#x60; to indicate that the server should \&quot;canonicalize\&quot; the content when searching for matching artifacts.  Canonicalization is unique to each artifact type, but typically involves removing any extra whitespace and formatting the content in a consistent manner.  Must be used along with the &#x60;artifactType&#x60; query parameter.
         * @param {string} [artifactType] Indicates the type of artifact represented by the content being used for the search.  This is only needed when using the &#x60;canonical&#x60; query parameter, so that the server knows how to canonicalize the content prior to searching for matching versions.
         * @param {number} [offset] The number of versions to skip before starting to collect the result set.  Defaults to 0.
         * @param {number} [limit] The number of versions to return.  Defaults to 20.
         * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
         * @param {VersionSortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
         * @param {string} [groupId] Filter by group Id.
         * @param {string} [artifactId] Filter by artifact Id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchVersionsByContent(body: File, canonical?: boolean, artifactType?: string, offset?: number, limit?: number, order?: SortOrder, orderby?: VersionSortBy, groupId?: string, artifactId?: string, options?: any): AxiosPromise<VersionSearchResults> {
            return localVarFp.searchVersionsByContent(body, canonical, artifactType, offset, limit, order, orderby, groupId, artifactId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the value of a single comment in an artifact version.  Only the owner of the comment can modify it.  The `artifactId`, unique `version` number, and `commentId`  must be provided.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * No comment with this `commentId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
         * @summary Update a comment
         * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
         * @param {string} versionExpression An expression resolvable to a specific version ID within the given group and artifact. The following rules apply:   - If the expression is in the form \&quot;branch&#x3D;{branchId}\&quot;, and artifact branch {branchId} exists: The expression is resolved to a version that the branch points to.  - Otherwise: The expression is resolved to a version with the same ID, which must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
         * @param {string} commentId The unique identifier of a single comment.
         * @param {NewComment} newComment 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArtifactVersionComment(groupId: string, artifactId: string, versionExpression: string, commentId: string, newComment: NewComment, options?: any): AxiosPromise<void> {
            return localVarFp.updateArtifactVersionComment(groupId, artifactId, versionExpression, commentId, newComment, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VersionsApi - object-oriented interface
 * @export
 * @class VersionsApi
 * @extends {BaseAPI}
 */
export class VersionsApi extends BaseAPI {
    /**
     * Adds a new comment to the artifact version.  Both the `artifactId` and the unique `version` number must be provided.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Add new comment
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} versionExpression An expression resolvable to a specific version ID within the given group and artifact. The following rules apply:   - If the expression is in the form \&quot;branch&#x3D;{branchId}\&quot;, and artifact branch {branchId} exists: The expression is resolved to a version that the branch points to.  - Otherwise: The expression is resolved to a version with the same ID, which must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
     * @param {NewComment} newComment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public addArtifactVersionComment(groupId: string, artifactId: string, versionExpression: string, newComment: NewComment, options?: RawAxiosRequestConfig) {
        return VersionsApiFp(this.configuration).addArtifactVersionComment(groupId, artifactId, versionExpression, newComment, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a new version of the artifact by uploading new content.  The configured rules for the artifact are applied, and if they all pass, the new content is added as the most recent  version of the artifact.  If any of the rules fail, an error is returned.  The body of the request can be the raw content of the new artifact version, or the raw content  and a set of references pointing to other artifacts, and the type of that content should match the artifact\'s type (for example if the artifact type is `AVRO` then the content of the request should be an Apache Avro document).  This operation can fail for the following reasons:  * Provided content (request body) was empty (HTTP error `400`) * An invalid version number was provided (HTTP error `400`) * No artifact with this `artifactId` exists (HTTP error `404`) * The new content violates one of the rules configured for the artifact (HTTP error `409`) * A server error occurred (HTTP error `500`) 
     * @summary Create artifact version
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {CreateVersion} createVersion The version to be created.
     * @param {boolean} [dryRun] When set to &#x60;true&#x60;, the operation will not result in any changes. Instead, it will return a result based on whether the operation **would have succeeded**.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public createArtifactVersion(groupId: string, artifactId: string, createVersion: CreateVersion, dryRun?: boolean, options?: RawAxiosRequestConfig) {
        return VersionsApiFp(this.configuration).createArtifactVersion(groupId, artifactId, createVersion, dryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a single version of the artifact. Parameters `groupId`, `artifactId` and the unique `version` are needed. If this is the only version of the artifact, this operation is the same as  deleting the entire artifact.  This feature is disabled by default and it\'s discouraged for normal usage. To enable it, set the `registry.rest.artifact.deletion.enabled` property to true. This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`)  * Feature is disabled (HTTP error `405`)  * A server error occurred (HTTP error `500`) 
     * @summary Delete artifact version
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} versionExpression An expression resolvable to a specific version ID within the given group and artifact. The following rules apply:   - If the expression is in the form \&quot;branch&#x3D;{branchId}\&quot;, and artifact branch {branchId} exists: The expression is resolved to a version that the branch points to.  - Otherwise: The expression is resolved to a version with the same ID, which must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public deleteArtifactVersion(groupId: string, artifactId: string, versionExpression: string, options?: RawAxiosRequestConfig) {
        return VersionsApiFp(this.configuration).deleteArtifactVersion(groupId, artifactId, versionExpression, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a single comment in an artifact version.  Only the owner of the comment can delete it.  The `artifactId`, unique `version` number, and `commentId`  must be provided.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * No comment with this `commentId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Delete a single comment
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} versionExpression An expression resolvable to a specific version ID within the given group and artifact. The following rules apply:   - If the expression is in the form \&quot;branch&#x3D;{branchId}\&quot;, and artifact branch {branchId} exists: The expression is resolved to a version that the branch points to.  - Otherwise: The expression is resolved to a version with the same ID, which must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
     * @param {string} commentId The unique identifier of a single comment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public deleteArtifactVersionComment(groupId: string, artifactId: string, versionExpression: string, commentId: string, options?: RawAxiosRequestConfig) {
        return VersionsApiFp(this.configuration).deleteArtifactVersionComment(groupId, artifactId, versionExpression, commentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all comments for a version of an artifact.  Both the `artifactId` and the unique `version` number must be provided.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Get artifact version comments
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} versionExpression An expression resolvable to a specific version ID within the given group and artifact. The following rules apply:   - If the expression is in the form \&quot;branch&#x3D;{branchId}\&quot;, and artifact branch {branchId} exists: The expression is resolved to a version that the branch points to.  - Otherwise: The expression is resolved to a version with the same ID, which must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public getArtifactVersionComments(groupId: string, artifactId: string, versionExpression: string, options?: RawAxiosRequestConfig) {
        return VersionsApiFp(this.configuration).getArtifactVersionComments(groupId, artifactId, versionExpression, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a single version of the artifact content.  Both the `artifactId` and the unique `version` number must be provided.  The `Content-Type` of the response depends  on the artifact type.  In most cases, this is `application/json`, but for some types  it may be different (for example, `PROTOBUF`).  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Get artifact version
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} versionExpression An expression resolvable to a specific version ID within the given group and artifact. The following rules apply:   - If the expression is in the form \&quot;branch&#x3D;{branchId}\&quot;, and artifact branch {branchId} exists: The expression is resolved to a version that the branch points to.  - Otherwise: The expression is resolved to a version with the same ID, which must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
     * @param {HandleReferencesType} [references] Allows the user to specify how references in the content should be treated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public getArtifactVersionContent(groupId: string, artifactId: string, versionExpression: string, references?: HandleReferencesType, options?: RawAxiosRequestConfig) {
        return VersionsApiFp(this.configuration).getArtifactVersionContent(groupId, artifactId, versionExpression, references, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all references for a single version of an artifact.  Both the `artifactId` and the unique `version` number must be provided.  Using the `refType` query parameter, it is possible to retrieve an array of either the inbound or outbound references.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Get artifact version references
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} versionExpression An expression resolvable to a specific version ID within the given group and artifact. The following rules apply:   - If the expression is in the form \&quot;branch&#x3D;{branchId}\&quot;, and artifact branch {branchId} exists: The expression is resolved to a version that the branch points to.  - Otherwise: The expression is resolved to a version with the same ID, which must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
     * @param {ReferenceType} [refType] Determines the type of reference to return, either INBOUND or OUTBOUND.  Defaults to OUTBOUND.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public getArtifactVersionReferences(groupId: string, artifactId: string, versionExpression: string, refType?: ReferenceType, options?: RawAxiosRequestConfig) {
        return VersionsApiFp(this.configuration).getArtifactVersionReferences(groupId, artifactId, versionExpression, refType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all versions of the artifact.  The result set is paged.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary List artifact versions
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {number} [offset] The number of versions to skip before starting to collect the result set.  Defaults to 0.
     * @param {number} [limit] The number of versions to return.  Defaults to 20.
     * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
     * @param {VersionSortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;version&#x60; * &#x60;createdOn&#x60; 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public listArtifactVersions(groupId: string, artifactId: string, offset?: number, limit?: number, order?: SortOrder, orderby?: VersionSortBy, options?: RawAxiosRequestConfig) {
        return VersionsApiFp(this.configuration).listArtifactVersions(groupId, artifactId, offset, limit, order, orderby, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of all versions that match the provided filter criteria.  This operation can fail for the following reasons:  * A server error occurred (HTTP error `500`) 
     * @summary Search for versions
     * @param {string} [version] Filter by version number.
     * @param {number} [offset] The number of versions to skip before starting to collect the result set.  Defaults to 0.
     * @param {number} [limit] The number of versions to return.  Defaults to 20.
     * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
     * @param {VersionSortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
     * @param {Array<string>} [labels] Filter by one or more name/value label.  Separate each name/value pair using a colon.  For example &#x60;labels&#x3D;foo:bar&#x60; will return only artifacts with a label named &#x60;foo&#x60; and value &#x60;bar&#x60;.
     * @param {string} [description] Filter by description.
     * @param {string} [groupId] Filter by artifact group.
     * @param {number} [globalId] Filter by globalId.
     * @param {number} [contentId] Filter by contentId.
     * @param {string} [artifactId] Filter by artifactId.
     * @param {string} [name] Filter by name.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public searchVersions(version?: string, offset?: number, limit?: number, order?: SortOrder, orderby?: VersionSortBy, labels?: Array<string>, description?: string, groupId?: string, globalId?: number, contentId?: number, artifactId?: string, name?: string, options?: RawAxiosRequestConfig) {
        return VersionsApiFp(this.configuration).searchVersions(version, offset, limit, order, orderby, labels, description, groupId, globalId, contentId, artifactId, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of all versions that match the posted content.  This operation can fail for the following reasons:  * Provided content (request body) was empty (HTTP error `400`) * A server error occurred (HTTP error `500`) 
     * @summary Search for versions by content
     * @param {File} body The content to search for.
     * @param {boolean} [canonical] Parameter that can be set to &#x60;true&#x60; to indicate that the server should \&quot;canonicalize\&quot; the content when searching for matching artifacts.  Canonicalization is unique to each artifact type, but typically involves removing any extra whitespace and formatting the content in a consistent manner.  Must be used along with the &#x60;artifactType&#x60; query parameter.
     * @param {string} [artifactType] Indicates the type of artifact represented by the content being used for the search.  This is only needed when using the &#x60;canonical&#x60; query parameter, so that the server knows how to canonicalize the content prior to searching for matching versions.
     * @param {number} [offset] The number of versions to skip before starting to collect the result set.  Defaults to 0.
     * @param {number} [limit] The number of versions to return.  Defaults to 20.
     * @param {SortOrder} [order] Sort order, ascending (&#x60;asc&#x60;) or descending (&#x60;desc&#x60;).
     * @param {VersionSortBy} [orderby] The field to sort by.  Can be one of:  * &#x60;name&#x60; * &#x60;createdOn&#x60; 
     * @param {string} [groupId] Filter by group Id.
     * @param {string} [artifactId] Filter by artifact Id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public searchVersionsByContent(body: File, canonical?: boolean, artifactType?: string, offset?: number, limit?: number, order?: SortOrder, orderby?: VersionSortBy, groupId?: string, artifactId?: string, options?: RawAxiosRequestConfig) {
        return VersionsApiFp(this.configuration).searchVersionsByContent(body, canonical, artifactType, offset, limit, order, orderby, groupId, artifactId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the value of a single comment in an artifact version.  Only the owner of the comment can modify it.  The `artifactId`, unique `version` number, and `commentId`  must be provided.  This operation can fail for the following reasons:  * No artifact with this `artifactId` exists (HTTP error `404`) * No version with this `version` exists (HTTP error `404`) * No comment with this `commentId` exists (HTTP error `404`) * A server error occurred (HTTP error `500`) 
     * @summary Update a comment
     * @param {string} groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier. Must follow the \&quot;.{1,512}\&quot; pattern.
     * @param {string} versionExpression An expression resolvable to a specific version ID within the given group and artifact. The following rules apply:   - If the expression is in the form \&quot;branch&#x3D;{branchId}\&quot;, and artifact branch {branchId} exists: The expression is resolved to a version that the branch points to.  - Otherwise: The expression is resolved to a version with the same ID, which must follow the \&quot;[a-zA-Z0-9._\\\\-+]{1,256}\&quot; pattern.
     * @param {string} commentId The unique identifier of a single comment.
     * @param {NewComment} newComment 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionsApi
     */
    public updateArtifactVersionComment(groupId: string, artifactId: string, versionExpression: string, commentId: string, newComment: NewComment, options?: RawAxiosRequestConfig) {
        return VersionsApiFp(this.configuration).updateArtifactVersionComment(groupId, artifactId, versionExpression, commentId, newComment, options).then((request) => request(this.axios, this.basePath));
    }
}



